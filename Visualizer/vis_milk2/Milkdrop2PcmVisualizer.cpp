//
// =================================================================
//
// BeatDrop/Milkwave - A Milkdrop2 Music Visualizer
//
// Authors : Maxim Volskiy (https://github.com/mvsoft74/BeatDrop) et al.
//
// From the readme :
// BeatDrop is a stand - alone implementation of the amazing Milkdrop2 Winamp plug-in.
// It lets you experience the stunning visual 2D effects with your music player of choice.
// No additional configuration steps needed!Just start BeatDrop and play your music.
// Use BeatDrop with your favourite Music player.
//
// The concept is realized by using audio loopback capture by Matthew van Eerde
// https://github.com/mvaneerde/blog
//
// =================================================================
//
//	                  Modified for Spout output
//
//                https://github.com/leadedge/BeatDrop
//
//					      Lynn Jarvis 2018-2023
//
//                       http://spout.zeal.co/
//
// Spout output can be imported into any host program with Spout support
// or by using the SpoutReceiver FreeframeGL plugin for Freeframe hosts.
// The visuals will then react to audio generated by the host itself.
// Search for "SPOUT" to find code changes.
//
//	Key functions changed slightly :
//
//  ESC  exit help / menus
//
//  F1   help
//  F4   preset name
//  F5   frames per second
//  F6   preset rating
//  F8   change preset folder
//	F9   toggle max fps 60/30
//  F12  show / hide render window
//
//  PRESET BROWSING :
//  SPACE     soft transition to next preset
//  H         instant hard cut to next preset
//  BACKSPACE go back to previous preset
//  ` or ~lock / unlock current preset
//  R         toggle random / sequential preset order
//  L         load specific preset
//  + / -rate current preset(better / worse)
//
//  PRESET EDITING AND SAVING
//  M    show / hide preset - editing Menu
//  S    save new preset
//  A    do random mini - mash - up
//  D    toggle warp & comp shader locks
//
// Revisons : see plugin.cpp
// NOTE : The device must be D3D9ex and not D3D9.
// See : void InitD3d(HWND hwnd, int width, int height)
// Changes throughout. Search for "DX9EX".
// Credit : Patrick Pomerleau - NEST Immersion.
//
// =================================================================
//
// Licencing :
//
// BeatDrop Copyright (c) 2018 Maxim Volskiy and individual contributors
// licenced with the 3-Clause BSD License (https://opensource.org/licenses/BSD-3-Clause) 
// with the exception of where otherwise noted.
//
// Original MilkDrop code by Ryan Geiss and Rovastar (John Baker)
// https://sourceforge.net/projects/milkdrop2/
//
// =================================================================
//
// Spout modifications : Copyright(C) 2018-2023, Lynn Jarvis. All rights reserved.
//
// licenced with 3-Clause BSD License.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met :
// 
// 1. Redistributions of source code must retain the above copyright notice,
// this list of conditions and the following disclaimer.
// 
// 2. Redistributions in binary form must reproduce the above copyright notice,
// this list of conditions and the following disclaimer in the documentation
// and/or other materials provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of its contributors
// may be used to endorse or promote products derived from this software without
// specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"	AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE	ARE DISCLAIMED.
// IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES(INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// 
// =================================================================

#ifdef DEBUG
#define _CRTDBG_MAP_ALLOC
#endif

// Define VK_B if it is not already defined
#ifndef VK_B
#define VK_B 0x42 // ASCII code for 'B'
#endif

// Define VK_C if it is not already defined
#ifndef VK_C
#define VK_C 0x43 // ASCII code for 'C'
#endif

#ifndef VK_D
#define VK_D 0x44 // ASCII code for 'D'
#endif

#include <stdlib.h>
#include <malloc.h>
#include <crtdbg.h>

#include <windows.h>
#include <process.h>
#include <d3d9.h>
#include <math.h>
#include <dwmapi.h>

#include <ShellScalingApi.h> // for dpi awareness
#pragma comment(lib, "shcore.lib") // for dpi awareness
// older Windows versions: Entry Point Not Found Fix

#include "plugin.h"
#include "resource.h"
#include "pluginshell.h"

#include <mutex>
#include <atomic>

//#include <core/sdk/constants.h>
//#include <core/sdk/IPcmVisualizer.h>
//#include <core/sdk/IPlaybackRemote.h>

#include "..\audio\common.h"
#include "milkwave.h"
#include <locale>
#include <codecvt>
#include "Milkdrop2PcmVisualizer.h"

#define DLL_EXPORT __declspec(dllexport)
//#define COMPILE_AS_DLL
#define SAMPLE_SIZE 576
#define DEFAULT_WIDTH 720;
#define DEFAULT_HEIGHT 720;

CPlugin g_plugin;
Milkwave milkwave;
HINSTANCE api_orig_hinstance = nullptr;
_locale_t g_use_C_locale;
char keyMappings[8];

// SPOUT
// ===============================================
static int nBeatDrops = 0; // Number of BeatDrop instances already running
BOOL CALLBACK GetWindowNames(HWND h, LPARAM l); // Window enumerator callback
// ===============================================

// SPOUT - DX9EX
static IDirect3D9Ex* pD3D9 = nullptr;
static IDirect3DDevice9Ex* pD3DDevice = nullptr;

static D3DPRESENT_PARAMETERS d3dPp;

static LONG lastWindowStyle = 0;
static LONG lastWindowStyleEx = 0;

static bool fullscreen = false;
static bool stretch = false;
static bool borderless = false;
static bool clickthrough = false;
static RECT lastRect = { 0 };

static HMODULE module = nullptr;
static std::atomic<HANDLE> threadRender = nullptr;
static std::atomic<HANDLE> threadSetup = nullptr;
static unsigned threadId = 0;
static std::mutex pcmMutex;
static unsigned char pcmLeftIn[SAMPLE_SIZE];
static unsigned char pcmRightIn[SAMPLE_SIZE];
static unsigned char pcmLeftOut[SAMPLE_SIZE];
static unsigned char pcmRightOut[SAMPLE_SIZE];

wchar_t m_szAudioDevice[MAX_PATH];
wchar_t m_szAudioDevicePrevious[MAX_PATH];

HANDLE hThreadLoopbackCapture;

bool pauseRender = false;

static HICON icon = nullptr;


// SPOUT
// ===============================================
BOOL CALLBACK GetWindowNames(HWND h, LPARAM l) {
  if (h == NULL)
    return FALSE;

  char search_window_name[MAX_PATH];

  if (IsWindow(h) && IsWindowVisible(h)) {
    GetWindowTextA(h, search_window_name, MAX_PATH);
    if (search_window_name[0]) {
      // Does the search window name contain "Milkwave Visualizer" ?
      if (strstr(search_window_name, "Milkwave Visualizer") != NULL) {
        nBeatDrops++;
      }
    }
  }
  return TRUE;
}
// ===============================================

// SPOUT - DX9EX
void InitD3d(HWND hwnd, int width, int height) {

  // TODO - error return
  HRESULT Hr = Direct3DCreate9Ex(D3D_SDK_VERSION, &pD3D9);

  D3DCAPS9 d3dCaps;

  D3DDISPLAYMODEEX mode;
  D3DDISPLAYROTATION rot;
  pD3D9->GetAdapterDisplayModeEx(D3DADAPTER_DEFAULT, &mode, &rot);

  UINT adapterId = g_plugin.m_adapterId;

  if (adapterId > pD3D9->GetAdapterCount()) {
    adapterId = D3DADAPTER_DEFAULT;
  }

  memset(&d3dPp, 0, sizeof(d3dPp));

  d3dPp.BackBufferCount = 1;
  d3dPp.BackBufferFormat = D3DFMT_UNKNOWN;// mode.Format;
  d3dPp.BackBufferWidth = width;
  d3dPp.BackBufferHeight = height;
  d3dPp.SwapEffect = D3DSWAPEFFECT_COPY;
  d3dPp.Flags = 0;
  d3dPp.EnableAutoDepthStencil = FALSE;// TRUE;
  d3dPp.AutoDepthStencilFormat = D3DFMT_D24S8;// D3DFMT_D24X8;
  d3dPp.Windowed = TRUE;
  d3dPp.PresentationInterval = D3DPRESENT_INTERVAL_ONE;
  d3dPp.MultiSampleType = D3DMULTISAMPLE_NONE;
  d3dPp.hDeviceWindow = (HWND)hwnd;

  // Test for hardware vertex processing capability and set up as needed
  // D3DCREATE_MULTITHREADED required by interop spec
  if (pD3D9->GetDeviceCaps(adapterId, D3DDEVTYPE_HAL, &d3dCaps) != S_OK) {
    printf("Milkdrop2PcmVisualizer::CreateDX9device - GetDeviceCaps error\n");
    return;
  }

  DWORD dwBehaviorFlags = D3DCREATE_PUREDEVICE | D3DCREATE_MULTITHREADED;
  if (d3dCaps.VertexProcessingCaps != 0)
    dwBehaviorFlags |= D3DCREATE_HARDWARE_VERTEXPROCESSING;
  else
    dwBehaviorFlags |= D3DCREATE_SOFTWARE_VERTEXPROCESSING;

  Hr = pD3D9->CreateDeviceEx(
    adapterId,
    D3DDEVTYPE_HAL,
    (HWND)hwnd,
    dwBehaviorFlags,
    &d3dPp,
    NULL,
    &pD3DDevice);
}

void DeinitD3d() {
  if (pD3DDevice) {
    pD3DDevice->Release();
    pD3DDevice = nullptr;
  }

  if (pD3D9) {
    pD3D9->Release();
    pD3D9 = nullptr;
  }
}

//Multiple monitor stretch - Credit to @milkdropper for the code!
void ToggleStretch(HWND hwnd) {
  if (!stretch) {
    ShowCursor(FALSE);
    int width = GetSystemMetrics(SM_CXVIRTUALSCREEN);
    int height = GetSystemMetrics(SM_CYVIRTUALSCREEN);
    int left = GetSystemMetrics(SM_XVIRTUALSCREEN);
    int top = GetSystemMetrics(SM_YVIRTUALSCREEN);

    if (!fullscreen) {
      lastWindowStyle = GetWindowLong(hwnd, GWL_STYLE);
      lastWindowStyleEx = GetWindowLongW(hwnd, GWL_EXSTYLE);
      lastWindowStyleEx &= ~WS_EX_TOPMOST;
      GetWindowRect(hwnd, &lastRect);
    }

    d3dPp.BackBufferWidth = width;
    d3dPp.BackBufferHeight = height;

    pD3DDevice->Reset(&d3dPp);

    SetWindowLongW(hwnd, GWL_STYLE, WS_POPUP | WS_VISIBLE);
    SetWindowLongW(hwnd, GWL_EXSTYLE, WS_EX_APPWINDOW);
    SetWindowPos(hwnd, HWND_NOTOPMOST, left, top, width, height, SWP_DRAWFRAME | SWP_FRAMECHANGED);
    SetThreadExecutionState(ES_DISPLAY_REQUIRED | ES_CONTINUOUS | ES_SYSTEM_REQUIRED | ES_AWAYMODE_REQUIRED);
    DragAcceptFiles(hwnd, TRUE);

    stretch = true;
  }
  else {
    ShowCursor(TRUE);

    int x = lastRect.left;
    int y = lastRect.top;
    int width = lastRect.right - lastRect.left;
    int height = lastRect.bottom - lastRect.top;

    d3dPp.BackBufferWidth = width;
    d3dPp.BackBufferHeight = height;

    pD3DDevice->Reset(&d3dPp);
    SetThreadExecutionState(ES_DISPLAY_REQUIRED | ES_SYSTEM_REQUIRED | ES_AWAYMODE_REQUIRED);
    stretch = false;

    SetWindowLongW(hwnd, GWL_STYLE, lastWindowStyle);
    SetWindowLongW(hwnd, GWL_EXSTYLE, lastWindowStyleEx);
    SetWindowPos(hwnd, HWND_NOTOPMOST, lastRect.left, lastRect.top, width, height, SWP_DRAWFRAME | SWP_FRAMECHANGED);
    SetWindowPos(hwnd, 0, 0, 0, 0, 0, SWP_DRAWFRAME | SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER);
    if (borderless) {
      SetWindowLongW(hwnd, GWL_STYLE, WS_POPUP | WS_VISIBLE);
      SetWindowPos(hwnd, HWND_TOPMOST, x, y, width, height, SWP_DRAWFRAME | SWP_FRAMECHANGED);
    }
  }
  fullscreen = false;
}

static void ToggleClickThrough(HWND hWnd) {
  try {


    // Retrieve the current alpha value
    BYTE currentAlpha = 255; // Default to fully opaque
    DWORD flags = 0;
    COLORREF colorKey = 0;
    if (GetLayeredWindowAttributes(hWnd, &colorKey, &currentAlpha, &flags)) {
      // Successfully retrieved the current alpha value
    }

    if (clickthrough) {
      // Make the window normal while retaining WS_EX_LAYERED
      LONG_PTR style = GetWindowLongPtr(hWnd, GWL_EXSTYLE);
      style &= ~WS_EX_TRANSPARENT; // Remove click-through
      SetWindowLongPtr(hWnd, GWL_EXSTYLE, style);
      SetLayeredWindowAttributes(hWnd, 0, currentAlpha, LWA_ALPHA);
    }
    else {
      // Make the window click-through
      LONG_PTR style = GetWindowLongPtr(hWnd, GWL_EXSTYLE);
      style |= WS_EX_LAYERED | WS_EX_TRANSPARENT;
      SetWindowLongPtr(hWnd, GWL_EXSTYLE, style);
      SetLayeredWindowAttributes(hWnd, 0, currentAlpha, LWA_ALPHA);
    }
    clickthrough = !clickthrough;
  } catch (const std::exception& e) {
    milkwave.LogException(L"ToggleClickThrough", e, true);
  }
}

static void ToggleBorderlessFullscreen(HWND hWnd) {
  try {
    static bool previousClickthrough = false; // Store the previous clickthrough state
    static float previousOpacity = 1.0f; // Store the previous opacity (fully opaque by default)

    // Check if Shift is pressed
    bool isShiftPressed = (GetKeyState(VK_SHIFT) & 0x8000) != 0;

    // Get the work area of the monitor (excluding the taskbar)
    MONITORINFO monitorInfo = { sizeof(MONITORINFO) };
    HMONITOR hMonitor = MonitorFromWindow(hWnd, MONITOR_DEFAULTTONEAREST);
    if (GetMonitorInfo(hMonitor, &monitorInfo)) {
      RECT workArea = monitorInfo.rcWork;

      // Check if the window is already in borderless fullscreen mode
      RECT currentRect;
      GetWindowRect(hWnd, &currentRect);

      if (currentRect.left == workArea.left &&
        currentRect.top == workArea.top &&
        currentRect.right == workArea.right &&
        currentRect.bottom == workArea.bottom) {
        // window appears to be borderless fullscreen
        // Restore the previous window dimensions, borderless state, clickthrough state, and opacity
        LONG_PTR style = GetWindowLongPtr(hWnd, GWL_STYLE);
        if (g_plugin.m_WindowBorderless) {
          style = WS_POPUP | WS_VISIBLE; // Restore borderless style
        }
        else {
          style = WS_OVERLAPPEDWINDOW | WS_VISIBLE; // Restore normal window style
        }
        SetWindowLongPtr(hWnd, GWL_STYLE, style);

        // Check if the saved dimensions are the same as the current dimensions
        if (g_plugin.m_WindowWidth == (currentRect.right - currentRect.left) &&
          g_plugin.m_WindowHeight == (currentRect.bottom - currentRect.top)) {
          // Reduce the dimensions by 50%
          g_plugin.m_WindowWidth /= 2;
          g_plugin.m_WindowHeight /= 2;

          // Center the window
          g_plugin.m_WindowX = (workArea.right - workArea.left - g_plugin.m_WindowWidth) / 2;
          g_plugin.m_WindowY = (workArea.bottom - workArea.top - g_plugin.m_WindowHeight) / 2;
        }

        SetWindowPos(
          hWnd,
          g_plugin.m_WindowBorderless ? HWND_TOPMOST : HWND_NOTOPMOST,
          g_plugin.m_WindowX,
          g_plugin.m_WindowY,
          g_plugin.m_WindowWidth,
          g_plugin.m_WindowHeight,
          SWP_FRAMECHANGED | SWP_NOZORDER | SWP_NOACTIVATE
        );

        // Restore the previous clickthrough state
        if (clickthrough != previousClickthrough) {
          ToggleClickThrough(hWnd);
        }

        if (g_plugin.fOpacity != previousOpacity) {
          g_plugin.fOpacity = previousOpacity;
          g_plugin.SetOpacity(hWnd);
        }

        // Restore the previous opacity
        // SetLayeredWindowAttributes(hWnd, 0, previousOpacity, LWA_ALPHA);

        borderless = g_plugin.m_WindowBorderless; // Restore the borderless state
        fullscreen = false;
      }
      else {
        // not in borderless fullscreen mode, so toggle to it
        // Save the current window dimensions, borderless state, clickthrough state, and opacity
        RECT currentWindowRect;
        GetWindowRect(hWnd, &currentWindowRect);
        g_plugin.m_WindowX = currentWindowRect.left;
        g_plugin.m_WindowY = currentWindowRect.top;
        g_plugin.m_WindowWidth = currentWindowRect.right - currentWindowRect.left;
        g_plugin.m_WindowHeight = currentWindowRect.bottom - currentWindowRect.top;
        g_plugin.m_WindowBorderless = borderless; // Save the current borderless state

        previousClickthrough = clickthrough; // Save the current clickthrough state
        previousOpacity = g_plugin.fOpacity;

        // Set the window style to borderless
        LONG_PTR style = GetWindowLongPtr(hWnd, GWL_STYLE);
        style &= ~(WS_OVERLAPPEDWINDOW); // Remove standard window styles
        style |= WS_POPUP; // Add popup style for borderless
        SetWindowLongPtr(hWnd, GWL_STYLE, style);

        // Set the window position and size to fit the work area
        SetWindowPos(
          hWnd,
          isShiftPressed ? HWND_TOPMOST : HWND_NOTOPMOST,
          workArea.left,
          workArea.top,
          workArea.right - workArea.left,
          workArea.bottom - workArea.top,
          SWP_FRAMECHANGED | SWP_NOACTIVATE
        );

        // If Shift is pressed, enable clickthrough
        if (isShiftPressed) {
          if (!clickthrough) {
            ToggleClickThrough(hWnd);
          }
          g_plugin.fOpacity = g_plugin.m_WindowWatermarkModeOpacity;
          g_plugin.SetOpacity(hWnd);
          //SetLayeredWindowAttributes(hWnd, 0, (BYTE)(g_plugin.m_WindowWatermarkModeOpacity * 255), LWA_ALPHA);
        }

        g_plugin.m_bAlwaysOnTop = isShiftPressed; // Set always on top based on Shift key state
        borderless = true;
      }
    }
  } catch (const std::exception& e) {
    milkwave.LogException(L"ToggleBorderlessFullscreen", e, true);
  }
}

static void ToggleFullScreen(HWND hwnd) {
  if (g_plugin.IsBorderlessFullscreen(hwnd)) {
    // ShowCursor(TRUE);
    ToggleBorderlessFullscreen(hwnd);
  }
  else if (!fullscreen) {
    ShowCursor(FALSE);

    if (!stretch) {
      lastWindowStyle = GetWindowLong(hwnd, GWL_STYLE);
      lastWindowStyleEx = GetWindowLongW(hwnd, GWL_EXSTYLE);
      lastWindowStyleEx &= ~WS_EX_TOPMOST;
      GetWindowRect(hwnd, &lastRect);
    }

    HMONITOR monitor = MonitorFromWindow(hwnd, MONITOR_DEFAULTTONEAREST);

    MONITORINFO info;
    info.cbSize = sizeof(MONITORINFO);

    GetMonitorInfoW(monitor, &info);

    int width = info.rcMonitor.right - info.rcMonitor.left;
    int height = info.rcMonitor.bottom - info.rcMonitor.top;

    SetWindowLongW(hwnd, GWL_STYLE, WS_POPUP | WS_VISIBLE);
    SetWindowLongW(hwnd, GWL_EXSTYLE, WS_EX_APPWINDOW);
    SetWindowPos(hwnd, HWND_TOPMOST, info.rcMonitor.left, info.rcMonitor.top, width, height, SWP_DRAWFRAME | SWP_FRAMECHANGED);

    d3dPp.BackBufferWidth = width;
    d3dPp.BackBufferHeight = height;

    HRESULT hr = pD3DDevice->Reset(&d3dPp);
    if (FAILED(hr)) {
      switch (hr) {
      case D3DERR_DEVICELOST:
        // Device is lost, cannot reset now. Retry later.
        g_plugin.AddError(L"Direct3D device is lost, retry later", 5.0f, ERR_NOTIFY, false);
        break;

      case D3DERR_DEVICENOTRESET:
        // Device is ready to be reset but failed. Consider releasing resources.
        g_plugin.AddError(L"Direct3D device could not be reset, releasing resources", 5.0f, ERR_NOTIFY, false);
        // Add code to release and recreate resources if necessary.
        break;

      case D3DERR_OUTOFVIDEOMEMORY:
        // Out of video memory.
        g_plugin.AddError(L"Out of video memory - Reduce resource usage", 5.0f, ERR_NOTIFY, false);
        break;

      case E_OUTOFMEMORY:
        // General memory allocation failure.
        g_plugin.AddError(L"Out of memory - Unable to reset device", 5.0f, ERR_NOTIFY, false);
        break;

      default:
        // Unknown error.
        wchar_t buf[256];
        swprintf(buf, 256, L"Unknown error during Reset: 0x%08X", hr);
        g_plugin.AddError(buf, 5.0f, ERR_NOTIFY, false);
        break;
      }

      // Optional: Fallback to windowed mode or attempt recovery.
      fullscreen = false;
      SetWindowLongW(hwnd, GWL_STYLE, lastWindowStyle);
      SetWindowLongW(hwnd, GWL_EXSTYLE, lastWindowStyleEx);
      SetWindowPos(hwnd, HWND_NOTOPMOST, lastRect.left, lastRect.top,
        lastRect.right - lastRect.left, lastRect.bottom - lastRect.top,
        SWP_DRAWFRAME | SWP_FRAMECHANGED);
    }

    SetThreadExecutionState(ES_DISPLAY_REQUIRED | ES_CONTINUOUS | ES_SYSTEM_REQUIRED | ES_AWAYMODE_REQUIRED);
    DragAcceptFiles(hwnd, TRUE);
    fullscreen = true;
  }
  else {
    ShowCursor(TRUE);

    int x = lastRect.left;
    int y = lastRect.top;
    int width = lastRect.right - lastRect.left;
    int height = lastRect.bottom - lastRect.top;

    d3dPp.BackBufferWidth = width;
    d3dPp.BackBufferHeight = height;

    pD3DDevice->Reset(&d3dPp);
    SetThreadExecutionState(ES_DISPLAY_REQUIRED | ES_SYSTEM_REQUIRED | ES_AWAYMODE_REQUIRED);
    fullscreen = false;

    SetWindowLongW(hwnd, GWL_STYLE, lastWindowStyle);
    SetWindowLongW(hwnd, GWL_EXSTYLE, lastWindowStyleEx);
    SetWindowPos(hwnd, HWND_NOTOPMOST, lastRect.left, lastRect.top, width, height, SWP_DRAWFRAME | SWP_FRAMECHANGED);
    SetWindowPos(hwnd, 0, 0, 0, 0, 0, SWP_DRAWFRAME | SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER);
    if (borderless) {
      SetWindowLongW(hwnd, GWL_STYLE, WS_POPUP | WS_VISIBLE);
      SetWindowPos(hwnd, HWND_TOPMOST, x, y, width, height, SWP_DRAWFRAME | SWP_FRAMECHANGED);
    }
  }
  stretch = false;
}

void SetWindowFixedDimensions(HWND hwnd) {
  int windowX = 0;
  int windowY = 0;

  RECT rect;
  if (GetWindowRect(hwnd, &rect)) {
    windowX = rect.left;
    windowY = rect.top;
  }

  // Restore the window to a normal state if minimized or maximized
  ShowWindow(hwnd, SW_RESTORE);

  // Adjust the window size and position
  SetWindowPos(hwnd, HWND_NOTOPMOST, windowX, windowY, g_plugin.m_WindowFixedWidth, g_plugin.m_WindowFixedHeight, SWP_FRAMECHANGED | SWP_NOZORDER | SWP_NOACTIVATE);
}

void ResetWindow(HWND hwnd) {
  // Get the screen dimensions
  int screenWidth = GetSystemMetrics(SM_CXSCREEN);
  int screenHeight = GetSystemMetrics(SM_CYSCREEN);

  int windowWidth = screenWidth / 3;
  int windowHeight = screenHeight / 3;

  int windowX = screenWidth - windowWidth - windowWidth / 4;
  int windowY = windowHeight / 4;

  // Restore the window to a normal state if minimized or maximized
  ShowWindow(hwnd, SW_RESTORE);

  // Remove any transparency or click-through flags
  LONG_PTR exStyle = GetWindowLongPtr(hwnd, GWL_EXSTYLE);
  exStyle &= ~(WS_EX_LAYERED | WS_EX_TRANSPARENT); // Remove transparency and click-through
  SetWindowLongPtr(hwnd, GWL_EXSTYLE, exStyle);

  // Reset the window style to a standard overlapped window
  SetWindowLongW(hwnd, GWL_STYLE, WS_OVERLAPPEDWINDOW | WS_VISIBLE);

  // Adjust the window size and position
  SetWindowPos(hwnd, HWND_NOTOPMOST, windowX, windowY, windowWidth, windowHeight, SWP_FRAMECHANGED | SWP_NOZORDER | SWP_NOACTIVATE);

  // Ensure the window is fully opaque
  SetLayeredWindowAttributes(hwnd, 0, 255, LWA_ALPHA);

  g_plugin.fOpacity = 1.0f;
  g_plugin.m_WindowBorderless = false;
  borderless = false;
  clickthrough = false;
  fullscreen = false;
}

static void ToggleBorderlessWindow(HWND hwnd) {
  static RECT lastRect = { 0 }; // Store the previous window position and size
  GetWindowRect(hwnd, &lastRect);
  int x = lastRect.left;
  int y = lastRect.top;
  int width = lastRect.right - lastRect.left;
  int height = lastRect.bottom - lastRect.top;
  GetWindowRect(hwnd, &lastRect);

  static bool wasTransparent = false; // Track if the window was transparent before toggling

  // Check if the window currently has transparency
  BYTE currentAlpha = 255; // Default to fully opaque
  DWORD flags = 0;
  COLORREF colorKey = 0;
  if (GetLayeredWindowAttributes(hwnd, &colorKey, &currentAlpha, &flags)) {
    wasTransparent = (flags & LWA_COLORKEY) != 0; // Check if LWA_COLORKEY is set
  }

  // --- Preserve current topmost state ---
  // Determine if the window is currently topmost
  HWND hInsertAfter = HWND_NOTOPMOST;
  // WS_EX_TOPMOST is 0x00000008L
  LONG_PTR exStyle = GetWindowLongPtr(hwnd, GWL_EXSTYLE);
  if (exStyle & WS_EX_TOPMOST) {
    hInsertAfter = HWND_TOPMOST;
  }

  if (!borderless) {
    // Save the current window position and size

    // Set the window style to borderless
    SetWindowLongW(hwnd, GWL_STYLE, WS_POPUP | WS_VISIBLE);

    // Reapply transparency only if it was present before
    if (wasTransparent) {
      SetLayeredWindowAttributes(hwnd, RGB(0, 0, 0), 255, LWA_COLORKEY);
    }

    SetWindowPos(hwnd, hInsertAfter, x, y, width, height, SWP_DRAWFRAME | SWP_FRAMECHANGED);
    borderless = true;
  }
  else {
    // Restore the previous window style and position
    SetWindowLongW(hwnd, GWL_STYLE, WS_OVERLAPPEDWINDOW | WS_VISIBLE);

    // Reapply transparency only if it was present before
    if (wasTransparent) {
      SetLayeredWindowAttributes(hwnd, RGB(0, 0, 0), 255, LWA_COLORKEY);
    }

    SetWindowPos(hwnd, hInsertAfter, x, y, width, height, SWP_DRAWFRAME | SWP_FRAMECHANGED);
    borderless = false;
  }
  g_plugin.m_WindowBorderless = borderless;
}

LRESULT CALLBACK StaticWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {

  static bool rightMouseButtonHeld = false; // Track the state of the right mouse button  

  switch (uMsg) {
  case WM_CLOSE:
  {
    g_plugin.SaveWindowSizeAndPosition(hWnd);
    DestroyWindow(hWnd);
    UnregisterClassW(L"Direct3DWindowClass", NULL);
    return 0;
  }

  case WM_DESTROY:
  {
    PostQuitMessage(0);
    break;
  }

  case WM_MOVE:
  {
    // Get the current window rectangle
    RECT windowRect;
    GetWindowRect(hWnd, &windowRect);

    // Get the virtual screen area (spanning all monitors)
    int virtualLeft = GetSystemMetrics(SM_XVIRTUALSCREEN);
    int virtualTop = GetSystemMetrics(SM_YVIRTUALSCREEN);
    int virtualWidth = GetSystemMetrics(SM_CXVIRTUALSCREEN);
    int virtualHeight = GetSystemMetrics(SM_CYVIRTUALSCREEN);

    int virtualRight = virtualLeft + virtualWidth;
    int virtualBottom = virtualTop + virtualHeight;

    int windowWidth = windowRect.right - windowRect.left;
    int windowHeight = windowRect.bottom - windowRect.top;

    // Constrain the window to stay within the virtual screen area
    int newX = windowRect.left;
    int newY = windowRect.top;

    if (newX < virtualLeft) {
      newX = virtualLeft;
    }
    if (newY < virtualTop) {
      newY = virtualTop;
    }
    if (newX + windowWidth > virtualRight) {
      newX = virtualRight - windowWidth;
    }
    if (newY + windowHeight > virtualBottom) {
      newY = virtualBottom - windowHeight;
    }

    // Set the new position if adjustments were made
    if (newX != windowRect.left || newY != windowRect.top) {
      SetWindowPos(hWnd, NULL, newX, newY, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
    }
    break;
  }

  case WM_KEYDOWN:
  {
    g_plugin.PluginShellWindowProc(hWnd, uMsg, wParam, lParam);
  }
  if (wParam == VK_F2) {
    bool isCtrlPressed = (GetKeyState(VK_CONTROL) & 0x8000) != 0;
    if (isCtrlPressed) {
      bool isShiftPressed = (GetKeyState(VK_SHIFT) & 0x8000) != 0;
      if (isShiftPressed) {
        SetWindowFixedDimensions(hWnd);
      }
      else {
        ResetWindow(hWnd);
      }
    }
    else if (!fullscreen && !stretch) {
      ToggleBorderlessWindow(hWnd);
    }
  }
  if (wParam == VK_F9) {
    bool isCtrlPressed = (GetKeyState(VK_CONTROL) & 0x8000) != 0;
    if (isCtrlPressed) {
      ToggleBorderlessFullscreen(hWnd);
    }
    else {
      ToggleClickThrough(hWnd);
      if (clickthrough) {
        g_plugin.AddNotification(L"Clickthrough Mode enabled");
      }
      else {
        g_plugin.AddNotification(L"Clickthrough Mode disabled");
      }
    }
  }
  else if (wParam == VK_B) {
    if (GetKeyState(VK_CONTROL) & 0x8000) { // Check if Ctrl is pressed
      g_plugin.m_SongInfoPollingEnabled = !g_plugin.m_SongInfoPollingEnabled;
      milkwave.doPoll = g_plugin.m_SongInfoPollingEnabled;
      if (g_plugin.m_SongInfoPollingEnabled) {
        g_plugin.AddNotification(L"Song Info enabled");
      }
      else {
        g_plugin.AddNotification(L"Song Info disabled");
        milkwave.currentArtist = L"";
        milkwave.currentTitle = L"";
        milkwave.currentAlbum = L"";
      }
    }
    else {
      milkwave.doPollExplicit = true;
    }
    return 0;
  }
  else if (wParam == VK_C) {
    if (GetKeyState(VK_CONTROL) & 0x8000) { // Check if Ctrl is pressed
      g_plugin.m_DisplayCover = !g_plugin.m_DisplayCover;
      milkwave.doSaveCover = g_plugin.m_DisplayCover;
      if (g_plugin.m_DisplayCover) {
        g_plugin.AddNotification(L"Cover Display enabled");
      }
      else {
        g_plugin.AddNotification(L"Cover Display disabled");
      }
    }
    else {
      milkwave.doPollExplicit = true;
    }
    return 0;
  }
  else if (wParam == VK_D) {
    if (GetKeyState(VK_CONTROL) & 0x8000) { // Check if Ctrl is pressed
      g_plugin.AddNotification(g_plugin.m_szAudioDeviceDisplayName);
    }
    return 0;
  }
  break;

  case WM_NCHITTEST: //used for borderless window
  {
    // if (borderless)
    if (!fullscreen && !stretch) {
      //resizable borderless
      //from https://stackoverflow.com/questions/19106047/winapi-c-reprogramming-window-resize
#define BORDERWIDTH  10
#define TITLEBARWIDTH  30
      RECT rect;
      int x, y;
      GetWindowRect(hWnd, &rect);

      x = GET_X_LPARAM(lParam) - rect.left;
      y = GET_Y_LPARAM(lParam) - rect.top;

      if (x >= BORDERWIDTH && x <= rect.right - rect.left - BORDERWIDTH && y >= BORDERWIDTH && y <= TITLEBARWIDTH)
        return HTCAPTION;

      else if (x < BORDERWIDTH && y < BORDERWIDTH)
        return HTTOPLEFT;
      else if (x > rect.right - rect.left - BORDERWIDTH && y < BORDERWIDTH)
        return HTTOPRIGHT;
      else if (x > rect.right - rect.left - BORDERWIDTH && y > rect.bottom - rect.top - BORDERWIDTH)
        return HTBOTTOMRIGHT;
      else if (x < BORDERWIDTH && y > rect.bottom - rect.top - BORDERWIDTH)
        return HTBOTTOMLEFT;

      else if (x < BORDERWIDTH)
        return HTLEFT;
      else if (y < BORDERWIDTH)
        return HTTOP;
      else if (x > rect.right - rect.left - BORDERWIDTH)
        return HTRIGHT;
      else if (y > rect.bottom - rect.top - BORDERWIDTH)
        return HTBOTTOM;
      return HTCAPTION;
    }
    break;
  }

  case WM_NCLBUTTONDBLCLK:
  {
    // if (borderless)
    // only triggered when going INTO fullscreen
    ToggleFullScreen(hWnd);
    return 0;
    // break;
  }

  case WM_NCRBUTTONDBLCLK:
  {
    ToggleBorderlessWindow(hWnd);
    break;
  }

  case WM_SYSKEYDOWN:
  {
    if (wParam == VK_F4) { // SPOUT ??
      PostQuitMessage(0);
    }
    else if (wParam == 'S' || wParam == 's') {
      ToggleStretch(hWnd);
    }
    else if (wParam == VK_RETURN) {
      ToggleFullScreen(hWnd);
    }
    else {
      g_plugin.PluginShellWindowProc(hWnd, uMsg, wParam, lParam);
    }
    break;
  }

  case WM_RBUTTONDOWN:
  case WM_NCRBUTTONDOWN: // Right mouse button pressed
    rightMouseButtonHeld = true;
    break;

  case WM_RBUTTONUP:
  case WM_NCRBUTTONUP: // Right mouse button released
    rightMouseButtonHeld = false;
    break;

  case WM_LBUTTONDOWN:
  case WM_NCLBUTTONDOWN: // Left mouse button pressed
    if (rightMouseButtonHeld) {
      // Right + Left
      PostMessage(hWnd, WM_CLOSE, 0, 0); // Close the window
    }
    break;

  case WM_MBUTTONDOWN:
  case WM_NCMBUTTONDOWN: // Middle mouse button clicked
    if (rightMouseButtonHeld) {
      // Right + Middle
      g_plugin.OpenMilkwaveRemote();
    }
    else {
      // Middle only
      milkwave.doPollExplicit = true;
    }
    break;

  case WM_LBUTTONDBLCLK:
  {
    // only triggered when coming back from fullscreen
    ToggleFullScreen(hWnd);
    break;
  }

  case WM_RBUTTONDBLCLK:
  {
    ToggleBorderlessWindow(hWnd);
    break;
  }

  default:
    return g_plugin.PluginShellWindowProc(hWnd, uMsg, wParam, lParam);
  }

  return DefWindowProc(hWnd, uMsg, wParam, lParam);
}


void RenderFrame() {

  {
    std::unique_lock<std::mutex> lock(pcmMutex);
    memcpy(pcmLeftOut, pcmLeftIn, SAMPLE_SIZE);
    memcpy(pcmRightOut, pcmRightIn, SAMPLE_SIZE);
    memset(pcmLeftIn, 0, SAMPLE_SIZE);
    memset(pcmRightIn, 0, SAMPLE_SIZE);
  }

  milkwave.PollMediaInfo();
  if (milkwave.updated) {
    if (milkwave.isSongChange && !milkwave.doPollExplicit) {
      if (g_plugin.m_ChangePresetWithSong) {
        g_plugin.NextPreset(g_plugin.m_fBlendTimeAuto);
      }
      if (g_plugin.m_DisplayCover) {
        g_plugin.LaunchSprite(0, -1);
      }
    }

    if (milkwave.doPollExplicit && g_plugin.m_DisplayCoverWhenPressingB) {
      g_plugin.LaunchSprite(0, -1);
    }

    milkwave.doPollExplicit = false;
    wchar_t buf[512];

    // Convert wchar_t array to std::string
    std::wstring_convert<std::codecvt_utf8<wchar_t>> converter;
    std::string format = converter.to_bytes(g_plugin.m_SongInfoFormat);
    std::istringstream stream(format);
    std::vector<std::string> tokens;
    std::string token;

    // Split the string into tokens
    while (std::getline(stream, token, ';')) {
      tokens.push_back(token);
    }

    // remove existing song info display
    g_plugin.ClearErrors(ERR_MSG_BOTTOM_EXTRA_1);
    g_plugin.ClearErrors(ERR_MSG_BOTTOM_EXTRA_2);
    g_plugin.ClearErrors(ERR_MSG_BOTTOM_EXTRA_3);

    // Iterate over tokens in reverse order
    for (auto it = tokens.rbegin(); it != tokens.rend(); ++it) {
      std::string currentToken = *it;

      // Convert token to lowercase for case-insensitive comparison
      std::transform(currentToken.begin(), currentToken.end(), currentToken.begin(), ::tolower);

      if (currentToken == "artist") {
        if (milkwave.currentArtist.length() > 0) {
          wcscpy(buf, milkwave.currentArtist.c_str());
          g_plugin.AddError(buf, g_plugin.m_SongInfoDisplaySeconds, ERR_MSG_BOTTOM_EXTRA_1, false);
        }
      }
      else if (currentToken == "title") {
        if (milkwave.currentTitle.length() > 0) {
          wcscpy(buf, milkwave.currentTitle.c_str());
          g_plugin.AddError(buf, g_plugin.m_SongInfoDisplaySeconds, ERR_MSG_BOTTOM_EXTRA_2, false);
        }
      }
      else if (currentToken == "album") {
        if (milkwave.currentAlbum.length() > 0) {
          wcscpy(buf, milkwave.currentAlbum.c_str());
          g_plugin.AddError(buf, g_plugin.m_SongInfoDisplaySeconds, ERR_MSG_BOTTOM_EXTRA_3, false);
        }
      }
    }

    milkwave.updated = false;
  }

  g_plugin.PluginRender(
    (unsigned char*)pcmLeftOut,
    (unsigned char*)pcmRightOut);

}

// SPOUT
void ResizeBeatDrop(int newWidth, int newHeight) {
  // Client window size
  int width = 640;
  int height = 360;
  // If the window is square - 512x512, otherwise 640x360
  if (newWidth == newHeight) {
    width = 512;
    height = 512;
  }
  HWND hw = FindWindowA("Direct3DWindowClass", "Milkwave Visualizer");
  // Client to window
  RECT rc;
  SetRect(&rc, 0, 0, width, height);
  AdjustWindowRect(&rc, WS_OVERLAPPEDWINDOW, false);
  width = rc.right - rc.left;
  height = rc.bottom - rc.top;
  // Resize but do not move
  SetWindowPos(hw, NULL, 0, 0, width, height, SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOZORDER);
}


unsigned __stdcall CreateWindowAndRun(void* data) {

  HINSTANCE instance = (HINSTANCE)data;

#ifdef DEBUG
  _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
  _CrtSetBreakAlloc(60);
#endif

  // SPOUT
  // Set Per Monitor awareness
  SetProcessDpiAwareness(PROCESS_PER_MONITOR_DPI_AWARE); //older Windows versions: Entry Point Not Found Fix
  // SetProcessDpiAwarenessContext(DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE);

  // Register the windows class
  WNDCLASSW wndClass;
  wndClass.style = CS_DBLCLKS;
  wndClass.lpfnWndProc = StaticWndProc;
  wndClass.cbClsExtra = 0;
  wndClass.cbWndExtra = 0;
  wndClass.hInstance = instance;
  wndClass.hIcon = NULL;
  wndClass.hCursor = LoadCursor(NULL, IDC_ARROW);
  wndClass.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
  wndClass.lpszMenuName = NULL;
  wndClass.lpszClassName = L"Direct3DWindowClass";

  if (!RegisterClassW(&wndClass)) {
    DWORD dwError = GetLastError();
    if (dwError != ERROR_CLASS_ALREADY_EXISTS) {
      return 0;
    }
  }

  // SPOUT
  // Make the window a fixed size
    // The sender resolution is independent - see SpoutWidth/SpoutHeight below
  int windowWidth = 720; // standalone version 1280x720
  int windowHeight = 720;

  RECT rc;
  SetRect(&rc, 0, 0, windowWidth, windowHeight);
  AdjustWindowRect(&rc, WS_OVERLAPPEDWINDOW, false);

  // SPOUT
  // Centre on the desktop work area
  int WindowPosLeft = 0;
  int WindowPosTop = 0;
  RECT WorkArea;
  SystemParametersInfo(SPI_GETWORKAREA, 0, (LPVOID)&WorkArea, 0);
  WindowPosLeft += ((WorkArea.right - WorkArea.left) - windowWidth) / 2;
  WindowPosTop += ((WorkArea.bottom - WorkArea.top) - windowHeight) / 2;

  // SPOUT
  // Remove minimize and maximize
  //DWORD dwStyle = (WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME);

  // ===============================================
  // Enumerate other instances of BeatDrop to increment the title
  WCHAR BeatDroptitle[256];
  // printf("Number of existing BeatDrops (%d)\n", nBeatDrops);

  bool freeTitleFound = false;
  nBeatDrops = 0;

  while (!freeTitleFound && nBeatDrops < 100) {
    if (nBeatDrops == 0) {
      lstrcpyW(BeatDroptitle, L"Milkwave Visualizer");
    }
    else {
      swprintf_s(BeatDroptitle, L"Milkwave Visualizer %d", nBeatDrops + 1);
    }

    // Check if a window with this title already exists
    HWND existing = FindWindowW(L"Direct3DWindowClass", BeatDroptitle);
    if (existing != NULL) {
      nBeatDrops++;
      // Try next title
    }
    else {
      // No window with this title, so we can use it
      printf("New title [%S]\n", BeatDroptitle);
      freeTitleFound = true;
    }
  }

  // ===============================================

    // Create the render window
  HWND hwnd = CreateWindowW(
    L"Direct3DWindowClass",
    // ===========================
        // L"Milkwave",
    BeatDroptitle,
    // ===========================
    WS_OVERLAPPEDWINDOW, // SPOUT
    //dwStyle,
    g_plugin.m_WindowX,
    g_plugin.m_WindowY,
    g_plugin.m_WindowWidth,
    g_plugin.m_WindowHeight,
    0,
    NULL,
    instance,
    0);
  // ====================================================

  if (!hwnd) {
    DWORD dwError = GetLastError();
    return 0;
  }

  if (!icon) {
    icon = LoadIconW(instance, MAKEINTRESOURCEW(IDI_PLUGIN_ICON));
  }

  SendMessageW(hwnd, WM_SETICON, ICON_BIG, (LPARAM)icon);
  SendMessageW(hwnd, WM_SETICON, ICON_SMALL, (LPARAM)icon);

  // window was closed in borderless fullscreen mode
  if (g_plugin.IsBorderlessFullscreen(hwnd)) {
    g_plugin.fOpacity = g_plugin.m_WindowWatermarkModeOpacity;
    g_plugin.SetOpacity(hwnd);
    if (!clickthrough) ToggleClickThrough(hwnd);
    g_plugin.m_bAlwaysOnTop = true;
    g_plugin.ToggleAlwaysOnTop(hwnd);
  }
  else {
    if (g_plugin.fOpacity < 1) {
      g_plugin.SetOpacity(hwnd);
    }
  }

  ShowWindow(hwnd, SW_SHOW);

  if (g_plugin.m_bAlwaysOnTop) {
    g_plugin.ToggleAlwaysOnTop(hwnd);
  }
  if (g_plugin.m_WindowBorderless && !borderless) {
    ToggleBorderlessWindow(hwnd);
  }

  milkwave.Init(g_plugin.m_szBaseDir);
  milkwave.doPoll = g_plugin.m_SongInfoPollingEnabled;
  milkwave.doSaveCover = g_plugin.m_DisplayCover;

  unsigned int frame = 0;

  // SPOUT - defaults if no GUI
    // Change the values here to set the fixed sender size
  unsigned int SpoutWidth = g_plugin.m_WindowWidth;
  unsigned int SpoutHeight = g_plugin.m_WindowHeight;

  // Set to windowWidth/windowHeight for a variable sender size
  // See milkDropfs.cpp RenderFrame - change to SendDX9surface(back_buffer, true); 
  // SpoutWidth = windowWidth;
  // SpoutHeight = windowHeight;

  unsigned int SpoutWidthOld = 0;
  unsigned int SpoutHeightOld = 0;
  // Read values if UI is open
  SpoutWidthOld = SpoutWidth;
  SpoutHeightOld = SpoutHeight;

  // Milkwave: Moved to StartThreads()
  // g_plugin.PluginPreInitialize(0, 0);

    // SPOUT
  // InitD3d(hwnd, windowWidth, windowHeight);
  InitD3d(hwnd, SpoutWidth, SpoutHeight);

  g_plugin.PluginInitialize(
    pD3DDevice,
    &d3dPp,
    hwnd,
    // windowWidth,
    // windowHeight);
    SpoutWidth,
    SpoutHeight);

  // g_plugin. .m_lpVS->

  MSG msg;
  msg.message = WM_NULL;

  try {
    PeekMessage(&msg, NULL, 0U, 0U, PM_NOREMOVE);
    while (WM_QUIT != msg.message) {
      try {
        if (PeekMessage(&msg, NULL, 0U, 0U, PM_REMOVE) != 0) {
          TranslateMessage(&msg);
          DispatchMessage(&msg);
        }
        else if (!pauseRender) {
          GetAudioBuf(pcmLeftIn, pcmRightIn, SAMPLE_SIZE);
          RenderFrame();
        }
      } catch (...) {
        // ignore
      }
      frame++;
      ////////////////////////////////////////////////////////////////////////////////////////////////
    }
  } catch (const std::exception& e) {
    milkwave.LogException(L"Exception in main loop", e, true);
  }

  g_plugin.MyWriteConfig();
  g_plugin.PluginQuit();

  DeinitD3d();

  threadRender = nullptr;
  threadId = 0;

  milkwave.LogInfo(L"CreateWindowAndRun ended");

  return 1;
}

void StartRenderThread(HINSTANCE instance) {
  threadRender = (HANDLE)_beginthreadex(
    nullptr,
    0,
    &CreateWindowAndRun,
    (void*)instance,
    0,
    &threadId);
}

int StartAudioCaptureThread(HINSTANCE instance) {

  try {

    HRESULT hr = S_OK;

    hr = CoInitialize(NULL);
    if (FAILED(hr)) {
      ERR(L"CoInitialize failed: hr = 0x%08x", hr);
      return -__LINE__;
    }
    CoUninitializeOnExit cuoe;

    // argc==1 No additional params. Output disabled.
    // argc==3 Two additional params. Output file enabled (32bit IEEE 754 FLOAT).
    // argc==4 Three additional params. Output file enabled (LITTLE ENDIAN PCM).
    int argc = 1;
    // LPCWSTR argv[4] = { L"", L"--file", L"loopback-capture.wav", L"--int-16" };
    LPCWSTR argv[4] = { L"", L"", L"", L"" };

    if (wcslen(g_plugin.m_szAudioDevice) > 0) {
      argc = 3;
      argv[1] = L"--device";
      argv[2] = g_plugin.m_szAudioDevice;
    };

    /*
    L"%ls [--device \"Device long name\"] [--file \"file name\"] [--int-16]\n"
      L"\n"
      L"    -? prints this message.\n"
      L"    --list-devices displays the long names of all active playback devices.\n"
      L"    --device captures from the specified device (default if omitted)\n"
      L"    --file saves the output to a file (%ls if omitted)\n"
      L"    --int-16 attempts to coerce data to 16-bit integer format",
     */

    hr = S_OK;


    // parse command line
    CPrefs prefs(argc, argv, hr, g_plugin.m_nAudioDeviceRequestType);
    if (FAILED(hr)) {
      ERR(L"CPrefs::CPrefs constructor failed: hr = 0x%08x", hr);
      return -__LINE__;
    }
    if (S_FALSE == hr) {
      // nothing to do
      return 0;
    }

    // create a "loopback capture has started" event
    HANDLE hStartedEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (NULL == hStartedEvent) {
      ERR(L"CreateEvent failed: last error is %u", GetLastError());
      return -__LINE__;
    }
    CloseHandleOnExit closeStartedEvent(hStartedEvent);

    // create a "stop capturing now" event
    HANDLE hStopEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (NULL == hStopEvent) {
      ERR(L"CreateEvent failed: last error is %u", GetLastError());
      return -__LINE__;
    }
    CloseHandleOnExit closeStopEvent(hStopEvent);

    g_plugin.SetAudioDeviceDisplayName(prefs.m_szAudioDeviceDisplayName.c_str());

    // create arguments for loopback capture thread
    LoopbackCaptureThreadFunctionArguments threadArgs;
    threadArgs.hr = E_UNEXPECTED; // thread will overwrite this
    threadArgs.pMMDevice = prefs.m_pMMDevice;
    threadArgs.bIsRenderDevice = prefs.m_bIsRenderDevice;
    threadArgs.bInt16 = prefs.m_bInt16;
    threadArgs.hFile = prefs.m_hFile;
    threadArgs.hStartedEvent = hStartedEvent;
    threadArgs.hStopEvent = hStopEvent;
    threadArgs.nFrames = 0;

    hThreadLoopbackCapture = CreateThread(
      NULL, 0,
      LoopbackCaptureThreadFunction, &threadArgs,
      0, NULL
    );
    if (NULL == hThreadLoopbackCapture) {
      ERR(L"CreateThread failed: last error is %u", GetLastError());
      return -__LINE__;
    }
    CloseHandleOnExit closeThread(hThreadLoopbackCapture);

    // wait for either capture to start or the thread to end
    HANDLE waitArray[2] = { hStartedEvent, hThreadLoopbackCapture };
    DWORD dwWaitResult;
    dwWaitResult = WaitForMultipleObjects(
      ARRAYSIZE(waitArray), waitArray,
      FALSE, INFINITE
    );

    if (WAIT_OBJECT_0 + 1 == dwWaitResult) {
      ERR(L"Thread aborted before starting to loopback capture: hr = 0x%08x", threadArgs.hr);
      return -__LINE__;
    }

    if (WAIT_OBJECT_0 != dwWaitResult) {
      ERR(L"Unexpected WaitForMultipleObjects return value %u", dwWaitResult);
      return -__LINE__;
    }

    // at this point capture is running
    // wait for the user to press a key or for capture to error out

    // /*HANDLE thread =*/ 
    // StartRenderThread(instance);
    // WaitForSingleObject(threadRender, INFINITE);

    //NEED TO STOP CAPTURE
    // at this point capture is running
    // wait for the user to press a key or for capture to error out
    {
      WaitForSingleObjectOnExit waitForThread(hThreadLoopbackCapture);
      SetEventOnExit setStopEvent(hStopEvent);

      /*
      HANDLE hStdIn = GetStdHandle(STD_INPUT_HANDLE);

      if (INVALID_HANDLE_VALUE == hStdIn) {
          ERR(L"GetStdHandle returned INVALID_HANDLE_VALUE: last error is %u", GetLastError());
          return -__LINE__;
      }

      LOG(L"%s", L"Press Enter to quit...");

      HANDLE rhHandles[2] = { hThreadLoopbackCapture, hStdIn };
      */
      g_plugin.m_nAudioLoopState = 0;
      bool bKeepWaiting = true;
      while (bKeepWaiting) {
        if (threadRender == nullptr) {
          // render thread stopped
          bKeepWaiting = false;
        }
        else if (g_plugin.m_nAudioLoopState == 1) {
          // audio device changed
          bKeepWaiting = false;
          g_plugin.m_nAudioLoopState = 2;
        }
        else {
          Sleep(100);
        }
      } // while
    } // naked scope

    // at this point the thread is definitely finished

  // MessageBoxA(NULL, "capture loop finished", "loopback", MB_OK);

    DWORD exitCode;
    if (!GetExitCodeThread(hThreadLoopbackCapture, &exitCode)) {
      ERR(L"GetExitCodeThread failed: last error is %u", GetLastError());
      return -__LINE__;
    }

    if (0 != exitCode) {
      ERR(L"Loopback capture thread exit code is %u; expected 0", exitCode);
      return -__LINE__;
    }

    if (S_OK != threadArgs.hr) {
      ERR(L"Thread HRESULT is 0x%08x", threadArgs.hr);
      return -__LINE__;
    }
    // let prefs' destructor call mmioClose

    if (g_plugin.m_nAudioLoopState == 2) {
      // pauseRender = true;
      if (g_plugin.m_nAudioDeviceRequestType == 1) {
        std::wstring statusMessage = std::wstring(g_plugin.m_szAudioDevice) + L" [In]";
        g_plugin.AddNotification(statusMessage.data());
      }
      else if (g_plugin.m_nAudioDeviceRequestType == 2) {
        std::wstring statusMessage = std::wstring(g_plugin.m_szAudioDevice) + L" [Out]";
        g_plugin.AddNotification(statusMessage.data());
      }
      else {
        g_plugin.AddNotification(g_plugin.m_szAudioDevice);
      }

      int result = StartAudioCaptureThread(instance);
      if (result != 0) {
        g_plugin.AddNotification(g_plugin.m_szAudioDevicePrevious);
        ERR(L"StartAudioCaptureThread failed: %d", result);

        std::wstring statusMessage = L"DEVICE=" + std::wstring(g_plugin.m_szAudioDevicePrevious);
        g_plugin.SendMessageToMilkwaveRemote(statusMessage.data());

        std::wstringstream ss;
        ss << L"STATUS=Device init failed, reverting to " << g_plugin.m_szAudioDevicePrevious;
        statusMessage = ss.str();
        g_plugin.SendMessageToMilkwaveRemote(statusMessage.data());


        wcscpy_s(g_plugin.m_szAudioDevice, g_plugin.m_szAudioDevicePrevious);
        result = StartAudioCaptureThread(instance);
      }
    }
  } catch (const std::exception& e) {
    milkwave.LogException(L"StartAudioCaptureThread", e, true);
  }
}

unsigned __stdcall DoSetup(void* param) {

  Sleep(3000); // wait for the render thread to initialize the plugin completely
  HINSTANCE instance = (HINSTANCE)param;
  
  if (g_plugin.m_ShaderCaching && g_plugin.m_ShaderPrecompileOnStartup) {

    std::wstring cacheDir = std::wstring(g_plugin.m_szBaseDir) + L"cache";
    std::wstring compiledListPath = cacheDir + L"\\compiled.txt";

    // Abort if compiled.txt already exists
    if (std::filesystem::exists(compiledListPath)) {
      //g_plugin.AddNotification(L"Shader cache already exists ,skipping precompilation");
      return -1;
    }

    // Open precompile.txt
    std::ifstream file("precompile.txt");
    if (!file.is_open()) {
      //g_plugin.AddNotification(L"Failed to open precompile.txt");
      return -1;
    }

    // Prepare output file for compiled shader list
    std::wofstream compiledList(compiledListPath);
    if (!compiledList.is_open()) {
      //g_plugin.AddNotification(L"Failed to create compiled.txt");
      return -1;
    }

    g_plugin.AddNotification(L"Precompiling shaders in the background...");

    int compiledShaders = 0;
    std::string line;
    auto start = std::chrono::high_resolution_clock::now();
    while (std::getline(file, line)) {
      // Convert to wide string
      std::wstring wLine(line.begin(), line.end());

      // Trim whitespace
      wLine.erase(0, wLine.find_first_not_of(L" \t"));
      wLine.erase(wLine.find_last_not_of(L" \t") + 1);

      // Skip empty lines or comments
      if (wLine.empty() || wLine[0] == L'#') continue;

      // Check for wildcard
      if (!wLine.empty() && wLine.back() == L'*') {
        std::wstring dirPath = wLine.substr(0, line.length() - 1); // Remove '*'
        if (std::filesystem::exists(dirPath)) {
          for (const auto& entry : std::filesystem::directory_iterator(dirPath)) {
            if (entry.is_regular_file()) {
              PrecompilePresetShaders(entry.path().wstring(), compiledList, compiledShaders);
            }
          }
        }
      }
      else {
        PrecompilePresetShaders(wLine, compiledList, compiledShaders);
      }
    }

    file.close();
    compiledList.close();
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration<double>(end - start); // fractional seconds
    std::wstringstream ss;
    ss << std::fixed << std::setprecision(2) << duration.count();

    std::wstring message = L"Precompiling " + std::to_wstring(compiledShaders) 
      + L" shaders completed in " + ss.str() + L"s";

    wchar_t szMessage[256];
    wcsncpy_s(szMessage, message.c_str(), _TRUNCATE);
    g_plugin.AddNotification(szMessage);    
  }
  return 0;
}

void PrecompilePresetShaders(std::wstring& wLine, std::wofstream& compiledList, int& compiledShaders) {
  wchar_t szFile[512];
  // Treat anything without a drive letter as relative
  if (wLine.find(L":\\") == std::wstring::npos) {
    lstrcpyW(szFile, g_plugin.m_szBaseDir);
    lstrcatW(szFile, wLine.c_str());
  }
  else {
    lstrcpyW(szFile, wLine.c_str());
  }

  // Compile the shader
  if (std::filesystem::exists(std::filesystem::path(szFile))) {
    auto start = std::chrono::high_resolution_clock::now();
    g_plugin.CompilePresetShadersToFile(szFile);
    auto end = std::chrono::high_resolution_clock::now();
    auto durationMs = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
    std::wstring warn = L" ";
    if (durationMs > 2000) {
      warn = L"!";
    }
    compiledList << warn << std::setw(8) << std::setfill(L' ') << durationMs << " " << szFile << std::endl;
    compiledShaders++;
  }
}

void StartSetupThread(HINSTANCE instance) {
  threadSetup = (HANDLE)_beginthreadex(
    nullptr,
    0,
    &DoSetup,
    (void*)instance,
    0,
    &threadId);
}

int StartThreads(HINSTANCE instance) {
  try {
    // Milkwave: early init so we can read audio device from settings
    g_plugin.PluginPreInitialize(0, 0);

    StartRenderThread(instance);
    // WaitForSingleObject(threadRender, INFINITE);

    StartSetupThread(instance);

    StartAudioCaptureThread(instance);

  } catch (const std::exception& e) {
    milkwave.LogException(L"StartThreads", e, true);
  }

  milkwave.LogInfo(L"StartThreads ended");

  return 0;
}

// SPOUT
//
// Test for DirectX installation and warn if not installed
// TODO : doesn't seem to need a header declaration
//
// Registry method only works for DirectX 9 and lower but that is OK
bool CheckForDirectX9c() {

  // HKLM\Software\Microsoft\DirectX\Version should be 4.09.00.0904
  // handy information : http://en.wikipedia.org/wiki/DirectX
  HKEY  hRegKey;
  LONG  regres;
  DWORD  dwSize, major, minor, revision, notused;
  char value[256];
  dwSize = 256;

  // Does the key exist
  regres = RegOpenKeyExA(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\DirectX", NULL, KEY_READ, &hRegKey);
  if (regres == ERROR_SUCCESS) {
    // Read the key
    regres = RegQueryValueExA(hRegKey, "Version", 0, NULL, (LPBYTE)value, &dwSize);
    // Decode the string : 4.09.00.0904
    sscanf_s(value, "%d.%d.%d.%d", &major, &minor, &notused, &revision);
    // printf("DirectX registry : [%s] (%d.%d.%d.%d)\n", value, major, minor, notused, revision);
    RegCloseKey(hRegKey);
    if (major == 4 && minor == 9 && revision == 904)
      return true;
  }

  return false;

}

void MilkwaveTerminateHandler() {
  try {
    // Re-throw the current exception to get its type/info
    std::exception_ptr exptr = std::current_exception();
    if (exptr) {
      try {
        std::rethrow_exception(exptr);
      } catch (const std::exception& e) {
        milkwave.LogException(L"Unhandled exception (std::terminate)", e, true);
      } catch (...) {
        milkwave.LogInfo(L"Unhandled non-std::exception in std::terminate");
      }
    }
    else {
      milkwave.LogInfo(L"std::terminate called with no active exception");
    }
  } catch (...) {
    // If logging itself throws, do nothing
  }
  std::abort(); // Ensure abnormal termination
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow) {
  std::set_terminate(MilkwaveTerminateHandler);
  api_orig_hinstance = hInstance;

#ifdef _DEBUG
  // Set the current directory to the Release folder for debugging,
  // which is expected to be at the project root level.
  SetCurrentDirectoryW(L"../../Release");
  wchar_t fullPath[MAX_PATH];
  GetCurrentDirectoryW(MAX_PATH, g_plugin.m_szBaseDir);
  // swprintf(cwd, sizeof(cwd) / sizeof(cwd[0]), L"WinMain: WorkingDir=%s\n", cwd);
  // Append backslash if not present
  size_t len = wcslen(g_plugin.m_szBaseDir);
  if (len > 0 && g_plugin.m_szBaseDir[len - 1] != L'\\') {
    if (len < MAX_PATH - 1) { // Ensure space for backslash and null terminator
      g_plugin.m_szBaseDir[len] = L'\\';
      g_plugin.m_szBaseDir[len + 1] = L'\0';
    }
  }
  OutputDebugStringW(g_plugin.m_szBaseDir);
  OutputDebugStringW(L"\n");
#else
  GetModuleFileNameW(NULL, g_plugin.m_szBaseDir, MAX_PATH);
#endif

  try {
    // test error logging
    // throw std::runtime_error("An example exception occurred.");
    if (CheckForDirectX9c())
      return StartThreads(hInstance);
    else
      return false;
  } catch (const std::exception& e) {
    milkwave.LogException(L"WinMain", e, true);
  }
  milkwave.LogInfo(L"WinMain ended");
}

static std::string title;

#ifdef DEBUG
struct _DEBUG_STATE {
  _DEBUG_STATE() {}

  ~_DEBUG_STATE() {
    _CrtDumpMemoryLeaks();
  }
};

_DEBUG_STATE ds;
#endif