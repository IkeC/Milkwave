MILKDROP_PRESET_VERSION=201
PSVERSION=4
PSVERSION_WARP=4
PSVERSION_COMP=4
comp_1=// ChunderFPV - Undulating Urchin / https://www.shadertoy.com/view/332XWd
comp_2=// Transpiled to HLSL using Milkwave
comp_3=
comp_4=#define A 9. // amplitude
comp_5=#define T (time/3e2)
comp_6=#define H(a) (cos(radians(float3(180, 90, 0))+(a)*6.2832)*.5+.5)  // hue
comp_7=
comp_8=float map(float3 u, float v)  // sdf
comp_9={
comp_10=float t = T,     // speed
comp_11=l = 5.,    // loop to reduce clipping
comp_12=f = 1e10, i = 0., y, z;
comp_13=
comp_14=u.xy = float2(atan2(u.x, u.y), length(u.xy));  // polar transform
comp_15=u.x += t*v*3.1416*.7;  // counter rotation
comp_16=
comp_17=for (; i++<l;)
comp_18={
comp_19=float3 p = u;
comp_20=y = round((p.y-i)/l)*l+i;
comp_21=p.x *= y;
comp_22=p.x -= y*y*t*3.1416;
comp_23=p.x -= round(p.x/6.2832)*6.2832;
comp_24=p.y -= y;
comp_25=z = cos(y*t*6.2832)*.5 +.5;  // z wave
comp_26=f = min(f, max(length(p.xy), -p.z -z*A) -.1 -z*.2 -p.z/1e2);  // tubes
comp_27=}
comp_28=return f;
comp_29=}
comp_30=
comp_31=
comp_32=shader_body {
comp_33= float4 C = 0;
comp_34= float2 U  = uv;
comp_35=// CONV: Center on screen, then try some aspect correction
comp_36=
comp_37=uv.x/=100;
comp_38=uv.y*=1.05;
comp_39=
comp_40=uv.x += 1 + 0.3*sin(0.1*time);
comp_41=uv.y += 1.1 + 0.3*sin(0.03*time);
comp_42=
comp_43=uv *= aspect.xy;
comp_44=
comp_45=// CONV: Adjust this to flip the output (±uv.x, ±uv.y)
comp_46=//uv = float2(uv.x, -uv.y);
comp_47=    float2 R = uv.xy, j,
comp_48=// CONV: iMouse unsupported
comp_49=         M = float2(0.5,0.5) * (1+0.5*sin(0.05*time)),
comp_50=         m = (M -R/2.)/R.y;
comp_51=    
comp_52=// CONV: iMouse unsupported
comp_53=//     if (iMouse.z < 1. && M.x+M.y < 10.) m = float2(0, .5);
comp_54=    
comp_55=    float3 o = float3(0, 0, -130.),  // camera
comp_56=         u = normalize(float3(U -R/2., R.y)),  // 3d coords
comp_57=         c = float3(0, 0, 0),
comp_58=         p, k;
comp_59=    
comp_60=    float t = T,
comp_61=          v = -o.z/3.,  // pattern scale
comp_62=          i = 0., d = i,
comp_63=          s, f, z, r;
comp_64=    
comp_65=    bool b;
comp_66=    
comp_67=    for (; i++<70;)  // raymarch
comp_68=    {
comp_69=        p = u*d +o;
comp_70=        p.xy /= v;           // scale down
comp_71=        r = 1.2*length(p.xy);    // radius
comp_72=        z = abs(1. -r*r);    // z warp
comp_73=        b = r < 1.;          // inside?
comp_74=        if (b) z = sqrt(z);
comp_75=        p.xy /= z+1.;        // spherize
comp_76=        p.xy -= m;           // move with mouse
comp_77=        p.xy *= 0.6*v;           // scale back up
comp_78=        p.xy -= cos(p.z/8. +t*3e2 +float2(0, 1.5708) +z/2.)*.2;  // wave along z
comp_79=        
comp_80=        s = map(p, v);  // sdf
comp_81=        
comp_82=        r = length(p.xy);                  // new r
comp_83=        f = cos(round(r)*t*6.2832)*.5+.5;  // multiples
comp_84=        k = H(.2 -f/3. +t +p.z/2e2);       // color
comp_85=        if (b) k = 1.-k;                   // flip color
comp_86=        
comp_87=        // this stuff can go outside the raymarch,
comp_88=        // but accumulating it here produces softer edges
comp_89=        c += min(exp(s/-.05), s)        // shapes
comp_90=           * (f+.01)                    // shade pattern
comp_91=           * min(z, 1.)                 // darken edges
comp_92=           * sqrt(cos(r*6.2832)*.5 +.5) // shade between rows
comp_93=           * k*k;                       // color
comp_94=        
comp_95=// CONV: break is unsupported, see Milkwave manual for details
comp_96=        if (s < 1e-3 || d > 1e3) i=70;
comp_97=        d += s*clamp(z, .3, .9);  // smaller steps towards sphere edge
comp_98=    }
comp_99=    
comp_100=// CONV: iChannel (textures) unsupported
comp_101=//     c += tex2D(iChannel0, u*d +o).rrr * float3(0, .4, s)*s*z*.03;  // wavy aqua
comp_102=    c += min(exp(-p.z -f*A)*z*k*.01/s, 1.);  // light tips
comp_103=        
comp_104=    j = p.xy/v +m;  // 2d coords
comp_105=    c /= clamp(dot(j, j)*4., .04, 4.);  // brightness
comp_106=    
comp_107=    C = float4(exp(log(c)/2.2), 1);
comp_108=ret=C;
comp_109=}
