MILKDROP_PRESET_VERSION=201
PSVERSION=4
PSVERSION_WARP=4
PSVERSION_COMP=4
comp_1=// stduhpf - another synthwave sunset thing / https://www.shadertoy.com/view/tsScRK
comp_2=// Transpiled to HLSL using Milkwave
comp_3=
comp_4=#define iChannel0 sampler_noise_lq
comp_5=
comp_6=sampler sampler_sun;
comp_7=
comp_8=float mod_conv(float x, float y) { return x - y * floor(x / y); }
comp_9=float2 mod_conv(float2 x, float2 y) { return x - y * floor(x / y); }
comp_10=float3 mod_conv(float3 x, float3 y) { return x - y * floor(x / y); }
comp_11=float4 mod_conv(float4 x, float4 y) { return x - y * floor(x / y); }
comp_12=
comp_13=#define speed 10
comp_14=#define wave_thing
comp_15=//#define city 1
comp_16=
comp_17=
comp_18=#define disable_sound_texture_sampling
comp_19=
comp_20=#ifndef disable_sound_texture_sampling
comp_21=#undef speed
comp_22=#define speed 5.
comp_23=#endif
comp_24=
comp_25=#define audio_vibration_amplitude .125
comp_26=
comp_27=float jTime;
comp_28=
comp_29=#ifdef disable_sound_texture_sampling
comp_30=#define textureMirror(a, b) float4(0,0,0,0)
comp_31=#else
comp_32=float4 textureMirror(sampler2D tex, float2 c){
comp_33=float2 cf = frac(c);
comp_34=return tex2D(tex,lerp(cf,1.-cf,mod_conv(floor(c),2.)));
comp_35=}
comp_36=#endif
comp_37=
comp_38=float amp(float2 p){
comp_39=return smoothstep(1,8.,abs(p.x));
comp_40=}
comp_41=
comp_42=float pow512(float a){
comp_43=a*=a;//^2
comp_44=a*=a;//^4
comp_45=a*=a;//^8
comp_46=a*=a;//^16
comp_47=a*=a;//^32
comp_48=a*=a;//^64
comp_49=a*=a;//^128
comp_50=a*=a;//^256
comp_51=return a*a;
comp_52=}
comp_53=
comp_54=float pow1d5(float a){
comp_55=return a*sqrt(a);
comp_56=}
comp_57=
comp_58=float hash21(float2 co){
comp_59=return frac(sin(dot(co.xy,float2(1.9898,7.233)))*45758.5433);
comp_60=}
comp_61=
comp_62=float hash(float2 uv_conv){
comp_63=float a = amp(uv_conv);
comp_64=#ifdef wave_thing
comp_65=float w = a>0.?(1.-.4*pow512(.51+.49*sin((.02*(uv_conv.y+.5*uv_conv.x)-jTime)*2.))):0.;
comp_66=#else
comp_67=float w=1.;
comp_68=#endif
comp_69=return (a>0 ? a*pow1d5(hash21(uv_conv))*w:0.)-(textureMirror(iChannel0,float2((uv_conv.x*29.uv_conv.y)*.03125,1.)).x)*audio_vibration_amplitude;
comp_70=}
comp_71=
comp_72=float edgeMin(float dx_c,float2 da, float2 db,float2 uv_conv){
comp_73=uv_conv.x+=5.;
comp_74=float3 c = frac((round(float3(uv_conv,uv_conv.x+uv_conv.y)))*(float3(0,1,2)+0.61803398875));
comp_75=
comp_76= float a1 = 1;
comp_77= float a2 = textureMirror(iChannel0,float2(c.x,0.)).x>.6?.15:1.;
comp_78= float a3 = textureMirror(iChannel0,float2(c.z,0.)).x>.6?.15:1.;
comp_79=
comp_80=return min(min((1-dx_c)*db.y*a3,da.x*a2),da.y*a1);
comp_81=}
comp_82=
comp_83=float2 trinoise(float2 uv_conv){
comp_84=const float sq = sqrt(3./2.);
comp_85=uv_conv.x *= sq;
comp_86=uv_conv.y -= .5*uv_conv.x;
comp_87=float2 d = frac(uv_conv);
comp_88=uv_conv -= d;
comp_89=
comp_90=bool c = dot(d,float2(1, 1))>1.;
comp_91=
comp_92=float2 dd = 1.-d;
comp_93=float2 da = c?dd:d,db = c?d:dd;
comp_94=
comp_95=float nn = hash(uv_conv+float(c));
comp_96=float n2 = hash(uv_conv+float2(1,0));
comp_97=float n3 = hash(uv_conv+float2(0,1));
comp_98=
comp_99=float nmid = lerp(n2,n3,d.y);
comp_100=float ns = lerp(nn,c?n2:n3,da.y);
comp_101=float dx = da.x/db.y;
comp_102=return float2(lerp(ns,nmid,dx),edgeMin(dx,da, db,uv_conv+d));
comp_103=}
comp_104=
comp_105=float2 map(float3 p){
comp_106=float2 n = trinoise(p.xz);
comp_107=return float2(p.y-2.*n.x,n.y);
comp_108=}
comp_109=
comp_110=float3 grad(float3 p){
comp_111=const float2 e = float2(.005,0);
comp_112=float a =map(p).x;
comp_113=return float3(map(p+e.xyy).x-a
comp_114=,map(p+e.yxy).x-a
comp_115=,map(p+e.yyx).x-a)/e.x;
comp_116=}
comp_117=
comp_118=float2 intersect(float3 ro,float3 rd){
comp_119=float d =0.,h=0.;
comp_120=float2 ret_c = 0;
comp_121=
comp_122=for(int i = 0;i<500;i++){ //look nice with 50 iterations
comp_123=float3 p = ro+d*rd;
comp_124=float2 s = map(p);
comp_125=h = s.x;
comp_126=d+= h*.5;
comp_127=if(abs(h)<.003*d) {
comp_128= ret_c = float2(d,s.y);
comp_129=} else {
comp_130= // CONV: break unsupported, see Milkwave manual
comp_131= if(d>150.|| p.y>2.) i=500;
comp_132=ret_c = float2(-1, -1);
comp_133=}
comp_134=
comp_135=}
comp_136=return ret_c;
comp_137=}
comp_138=
comp_139=void addsun(float3 rd,float3 ld,inout float3 col){
comp_140=
comp_141=float sun = smoothstep(.21,.2,distance(rd,ld));
comp_142=
comp_143=if(sun>0.){
comp_144=float yd = (rd.y-ld.y);
comp_145=
comp_146=float a =sin(3.1*exp(-(yd)*14.));
comp_147=
comp_148=sun*=smoothstep(-.8,0.,a);
comp_149=
comp_150=col = lerp(col,float3(1.,.8,.4)*.75,sun);
comp_151=}
comp_152=}
comp_153=
comp_154=float starnoise(float3 rd){
comp_155=float c = 0.;
comp_156=float3 p = normalize(rd)*300.;
comp_157=for (float i=0.;i<4.;i++)
comp_158={
comp_159=float3 q = frac(p)-.5;
comp_160=float3 id = floor(p);
comp_161=float c2 = smoothstep(.5,0.,length(q));
comp_162=c2 *= step(hash21(id.xz/id.y),.06-i*i*0.005);
comp_163=c += c2;
comp_164=p = mul(p*.6+.5*p, transpose(float3x3(3./5.,0,4./5.,0,1,0,-4./5.,0,3./5.)));
comp_165=}
comp_166=c*=c;
comp_167=float g = dot(sin(rd*10.512),cos(rd.yzx*10.512));
comp_168=c*=smoothstep(-3.14,-.9,g)*.5+.5*smoothstep(-.3,1.,g);
comp_169=return c*c;
comp_170=}
comp_171=
comp_172=float3 gsky(float3 rd,float3 ld,bool mask){
comp_173=float haze = exp2(-5.*(abs(rd.y)-.2*dot(rd,ld)));
comp_174=
comp_175=float st = mask?(starnoise(rd))*(1.-min(haze,1.)):0.;
comp_176=float3 back = float3(.4,.1,.7)*(1.-.5*textureMirror(iChannel0,float2(.5+.05*rd.x/rd.y,0.)).x
comp_177=*exp2(-.1*abs(length(rd.xz)/rd.y))
comp_178=*max(sign(rd.y),0.));
comp_179=#ifdef city
comp_180=float x = round(rd.x*30.);
comp_181=float h = hash21(float2(x-166.,x-166.));
comp_182=bool building = (h*h*.125*exp2(-x*x*x*x*.0025)>rd.y);
comp_183=if(mask && building)
comp_184=back*=0.,haze=.8, mask=mask && !building;
comp_185=#endif
comp_186=float3 col=clamp(lerp(back,float3(.7,.1,.4),haze)+st,0.,1.);
comp_187=if(mask)addsun(rd,ld,col);
comp_188=return col;
comp_189=}
comp_190=
comp_191=shader_body {
comp_192= float4 fragColor = 0;
comp_193=// CONV: Center on screen, then try some aspect correction
comp_194=uv = (uv*2) - 1;
comp_195=uv *= aspect.xy;
comp_196=// CONV: Adjust this to flip the output (±uv.x, ±uv.y)
comp_197=uv = float2(uv.x, -uv.y);
comp_198= float2 fragCoord  = uv;
comp_199=
comp_200=    fragColor=float4(0, 0, 0, 0);
comp_201=    #ifdef AA
comp_202=    for(float x = 0.;x<1.;x+=1./float(AA)){
comp_203=    for(float y = 0.;y<1.;y+=1./float(AA)){
comp_204=    #else
comp_205=        const float AA=1.,x=0.,y=0.;
comp_206=    #endif
comp_207=
comp_208=     //uv = (2.*(fragCoord+float2(x,y))-uv.xy)/uv.y;
comp_209=    
comp_210=    const float shutter_speed = .25; // for motion blur
comp_211=
comp_212=//float dt = frac(tex2D(iChannel0,float(AA)*(fragCoord+float2(x,y))/uv.xy).r+time)*shutter_speed;
comp_213=
comp_214=    float dt = frac(hash21(float(AA)*(fragCoord+float2(x,y)))+time)*shutter_speed;
comp_215=
comp_216=//    jTime = mod_conv(time-dt*timeDelta,4000.);
comp_217=
comp_218=//jTime = mod_conv(time-dt*timeDelta,4000.);
comp_219=jTime = time;
comp_220=
comp_221=    float3 ro = float3(0.,1,(-20000.+jTime*speed));
comp_222=    
comp_223=        #ifdef stereo
comp_224=            ro+=stereo*float3(.2*(float(uv.x>0.)-.5),0.,0.); 
comp_225=            const float de = .9;
comp_226=            uv.x=uv.x+.5*(uv.x>0.?-de:de);
comp_227=            uv*=2.;
comp_228=	#endif
comp_229=        
comp_230=    float3 rd = normalize(float3(uv,4./3.));//float3(uv,sqrt(1.-dot(uv,uv)));
comp_231=    
comp_232=    float2 i = intersect(ro,rd);
comp_233=    float d = i.x;
comp_234=    
comp_235=    float3 ld = normalize(float3(0,.125+.05*sin(.1*jTime),1));
comp_236=
comp_237=    float3 fog = d>0.?exp2(-d*float3(.14,.1,.28)):float3(0,0,0);
comp_238=    float3 sky = gsky(rd,ld,d<0.);
comp_239=    
comp_240=    float3 p = ro+d*rd;
comp_241=    float3 n = normalize(grad(p));
comp_242=    
comp_243=    float diff = dot(n,ld)+.1*n.y;
comp_244=    float3 col = float3(.1,.11,.18)*diff;
comp_245=    
comp_246=    float3 rfd = reflect(rd,n); 
comp_247=    float3 rfcol = gsky(rfd,ld,true);
comp_248=    
comp_249=    col = lerp(col,rfcol,.05+.95*pow(max(1.+dot(rd,n),0.),5.));
comp_250=
comp_251=    #ifdef VAPORWAVE
comp_252=    col = lerp(col,float3(.4,.5,1.),smoothstep(.05,.0,i.y));
comp_253=    col = lerp(sky,col,fog);
comp_254=    col = sqrt(col);
comp_255=    #else
comp_256=    col = lerp(col,float3(.8,.1,.92),smoothstep(.05,.0,i.y));
comp_257=    col = lerp(sky,col,fog);
comp_258=    //no gamma for that old cg look
comp_259=    #endif
comp_260=
comp_261=    if(d<0.)
comp_262=        d=1e6;
comp_263=    d=min(d,10.);
comp_264=
comp_265=    fragColor += float4(clamp(col,0.,1.),d<0.?0.:.1+exp2(-d));
comp_266=     #ifdef AA
comp_267=    }
comp_268=    }
comp_269=    fragColor/=float(AA*AA);
comp_270=    #endif
comp_271=
comp_272=    ret = fragColor;
comp_273=}
