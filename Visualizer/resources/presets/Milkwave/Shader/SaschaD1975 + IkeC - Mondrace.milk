MILKDROP_PRESET_VERSION=201
PSVERSION=4
PSVERSION_WARP=4
PSVERSION_COMP=4
comp_1=// SaschaD1975 + IkeC - Mondrace / https://www.shadertoy.com/view/t3yXRd
comp_2=// Transpiled to HLSL using Milkwave
comp_3=
comp_4=#define iChannel0 sampler_stoy_pebbles
comp_5=#define iChannel1 sampler_stoy_noise
comp_6=
comp_7=sampler iChannel0;
comp_8=sampler iChannel1;
comp_9=
comp_10=// Adjust if this takes long to compile
comp_11=// higher value = higher quality
comp_12=// Original value was 300
comp_13=
comp_14=#define LOOPS 20
comp_15=
comp_16=float map(float3 p) {
comp_17=  return p.y + tex2D(iChannel0, p.xz/20).r + tex2D(iChannel0, p.xz/200).r*20.;
comp_18=}
comp_19=
comp_20=float2 rot(float2 v, float a) { return cos(a)*v - sin(a)*float2(v.y, -v.x); }
comp_21=
comp_22=shader_body {
comp_23=  float4 fragColor = 0;
comp_24=  float2 fragCoord  = uv;
comp_25=  // CONV: Center on screen, then try some aspect correction
comp_26=
comp_27=  uv = (uv*2) - 1;
comp_28=  uv *= aspect.xy;
comp_29=  // CONV: Adjust this to flip the output (±uv.x, ±uv.y)
comp_30=  uv = float2(uv.x, -uv.y);
comp_31=  
comp_32=  #ifdef bass_smooth
comp_33=    float fac = (1+0.5*smoothstep(0,2,bass_smooth))*vis_intensity+vis_shift;
comp_34=  #else
comp_35=    float fac = 1+0.1*smoothstep(0,2,bass_att);
comp_36=  #endif
comp_37=
comp_38=  float3 ro = float3(0, 0, time*8.),
comp_39=  p,
comp_40=  rd = normalize(float3(rot(uv, sin(time/2.)/8.), 1));
comp_41=
comp_42=  ro.y = 1. -(map(ro) + map(ro + float3(0., 0., 1.0)))/8.;
comp_43=
comp_44=  float far = 50, marched = 0.01, c=0, d;
comp_45=
comp_46=  for (int i = 0; i < LOOPS; ++i) {
comp_47=    p = ro + rd*marched;
comp_48=    d = map(p);
comp_49=    marched += d*0.5;
comp_50=
comp_51=    // CONV: break is unsupported, see Milkwave manual for details
comp_52=    if (abs(d) < 0.001 || abs(d) > far) i=LOOPS;
comp_53=  }
comp_54=
comp_55=  if (marched < far) {
comp_56=    float2 ve = float2(0., 0.01);
comp_57=    float3 normal = normalize(float3(
comp_58=    map(p + ve.yxx),
comp_59=    map(p + ve.xyx),
comp_60=    map(p + ve.xxy)
comp_61=    ));
comp_62=
comp_63=    float3 ld = normalize(float3(sin(time/2.)*4., 1.0, 1.0));
comp_64=    c = (clamp(dot(ld, normal), 0., 1.) + step(frac(p.y*2.), 0.1))*(1. - distance(p, ro)/far);
comp_65=    } else {
comp_66=      c = pow(tex2D(iChannel1, uv*.5 + tex2D(iChannel1, uv*.3).xy + time/LOOPS).r, 15.)*.5;
comp_67=    }
comp_68=
comp_69=    // Output to screen
comp_70=    ret = float4(float3(c,c,c*fac),1.0);
comp_71=
comp_72=  }
