MILKDROP_PRESET_VERSION=201
PSVERSION=4
PSVERSION_WARP=4
PSVERSION_COMP=4
comp_1=// Marex + IkeC - Shadow Party Shader Jam 2025 / https://www.shadertoy.com/view/wf2cRR
comp_2=// Transpiled to HLSL using Milkwave
comp_3=
comp_4=#define tx sin(time)*0.5+1
comp_5=
comp_6=// 0.5 <= tx <= 1.5
comp_7=
comp_8=// CONV: setting iChannel samplers to default noise texture
comp_9=#define iChannel0 sampler_noise_lq
comp_10=
comp_11=// CONV: adding helper functions
comp_12=float mod_conv(float x, float y) { return x - y * floor(x / y); }
comp_13=float2 mod_conv(float2 x, float2 y) { return x - y * floor(x / y); }
comp_14=float3 mod_conv(float3 x, float3 y) { return x - y * floor(x / y); }
comp_15=float4 mod_conv(float4 x, float4 y) { return x - y * floor(x / y); }
comp_16=
comp_17=float2x2 R2D(float r){return float2x2(cos(r),-sin(r),sin(r),cos(r));}
comp_18=
comp_19=float sdf(float3 p, float T){
comp_20=  p.xyz = mod_conv(p.xyz-T,5.)-2.5;
comp_21=  float sp = length(p)-1.*sin(T)-1
comp_22=  ;
comp_23=  return sp;
comp_24=}
comp_25=
comp_26=float march(float2 uv_conv,  float3 eye, float3 ray, int n, float T) {
comp_27=  float total_distance = 0;
comp_28=  float3 p = eye;
comp_29=
comp_30=  for (int i = 0; i < n; i++) {
comp_31=    float d = sdf(p, T);
comp_32=    if (d < 0.001) {
comp_33=      i=n;
comp_34=    }
comp_35=
comp_36=    else {
comp_37=      p += d * ray;
comp_38=      total_distance += d;
comp_39=    }
comp_40=
comp_41=  }
comp_42=
comp_43=  return total_distance;
comp_44=}
comp_45=
comp_46=float3 normal(float3 p, float T) {
comp_47=  float2 e = .001 * float2(1, -1);
comp_48=  #define q(s) s * sdf(p + s, T)
comp_49=
comp_50=  return normalize(q(e.xyy) + q(e.yxy) + q(e.yyx) + q(e.xxx));
comp_51=}
comp_52=
comp_53=shader_body {
comp_54=  float4 fragColor = 0;
comp_55=  float2 fragCoord  = uv;
comp_56=  // CONV: Center on screen, then try some aspect correction
comp_57=  uv = (uv*2) - 1;
comp_58=  uv *= aspect.xy;
comp_59=  // CONV: Adjust this to flip the output (±uv.x, ±uv.y)
comp_60=  uv = float2(uv.x, -uv.y);
comp_61=
comp_62=  // uv = (2. * fragCoord.xy - uv.xy) / min(uv.x, uv.y);
comp_63=  // float2 R2D = uv;
comp_64=  float slowdown = 0.2;
comp_65=  float T = (sin(time*slowdown)+2)*1;
comp_66=
comp_67=  float2 R2D = mul(uv, R2D(100+time/8));
comp_68=  float3 color = float3(0, 0, 0);
comp_69=  float3 eye = float3(2.5, 0, 0);
comp_70=
comp_71=  float3 ray = normalize(float3(R2D, 1));
comp_72=
comp_73=  float d = march(uv,eye, ray, 128, T);
comp_74=  if (d > 0.) {
comp_75=    float3 p = eye + ray * d;
comp_76=    float3 n = normal(p, T);
comp_77=    float3 lo = float3(0, 2, -3);
comp_78=    float diffuse = max(0., dot(normalize(lo - p), n));
comp_79=    color = float3(10., 10., 10.) / p.z  * diffuse;
comp_80=  }
comp_81=
comp_82=  #ifdef bass_smooth
comp_83=    float fac = (int)vis_version > 2 ? 0.4*vis_intensity+vis_shift : (0.4 * clamp((int)vis_version == 1 ? bass_smooth : bass_att,0.3,1.7))*vis_intensity+vis_shift;
comp_84=  #else
comp_85=    float fac = 0.4 * clamp(bass_att,0.97,1.03);
comp_86=  #endif
comp_87=
comp_88=  float3 col = fac+.5*cos(time+uv.xyx+float3(0,2,4));
comp_89=
comp_90=  fragColor = float4(color * col,1.0);
comp_91=  ret = fragColor;
comp_92=}
