MILKDROP_PRESET_VERSION=201
PSVERSION=4
PSVERSION_WARP=4
PSVERSION_COMP=4
comp_1=// chronos + IkeC - Astral Jelly Journey / https://www.shadertoy.com/view/3cjBR1
comp_2=// Transpiled to HLSL using Milkwave
comp_3=
comp_4=#define tx (sin(time)*0.5+1)
comp_5=
comp_6=// CONV: adding helper functions
comp_7=float mod_conv(float x, float y) { return x - y * floor(x / y); }
comp_8=float2 mod_conv(float2 x, float2 y) { return x - y * floor(x / y); }
comp_9=float3 mod_conv(float3 x, float3 y) { return x - y * floor(x / y); }
comp_10=float4 mod_conv(float4 x, float4 y) { return x - y * floor(x / y); }
comp_11=
comp_12=float sRGBencode(float C_linear) { return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear); }
comp_13=float3 sRGBencode(float3 C_linear) { C_linear = clamp(C_linear, 0., 1.); return float3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z)); }
comp_14=
comp_15=float smin( float a, float b)
comp_16={
comp_17=  float x = (b-a)*5.;
comp_18=  float g = (x> 1.) ? x :
comp_19=  (x<-1.) ? 0. :
comp_20=  (x*(2.+x)+1.)*.25;
comp_21=  return b - .2 * g;
comp_22=}
comp_23=
comp_24=float smax( float a, float b)
comp_25={
comp_26=  return -smin(-a, -b);
comp_27=}
comp_28=
comp_29=float bubble(float3 p, float3 cell)
comp_30={
comp_31=  float2 pos = round(cell.xz);
comp_32=  float height = 40.;
comp_33=  float rnd = frac(4345.2134235*sin(dot(pos, float2(17.123, 11.54332))));
comp_34=  float3 q = float3(0,height*rnd,0);
comp_35=  q.xz = pos;
comp_36=  q.y += time *  (.9+.1*rnd);
comp_37=  q.y = mod_conv(q.y, height);
comp_38=  q.y -= height*.5;
comp_39=
comp_40=  // react to audio: bubble size
comp_41=  float res = length(p - q)-.025+0.01;
comp_42=  float fac = 0;
comp_43=  #ifdef bass_smooth
comp_44=  if (vis_version == 1) {
comp_45=    fac = clamp(0,2,bass_smooth)*0.04;
comp_46=  }
comp_47=
comp_48=  else if (vis_version == 2) {
comp_49=    fac = smoothstep(0,2,bass_att)*0.02;
comp_50=  }
comp_51=
comp_52=  fac = fac*vis_intensity+vis_shift;
comp_53=  #endif
comp_54=
comp_55=  return res-fac;
comp_56=}
comp_57=
comp_58=float bubbles(float3 p, float3 rd)
comp_59={
comp_60=  #if 0
comp_61=  return min(bubble(p, p),
comp_62=  min(
comp_63=  min(
comp_64=  bubble(p, p+float3(1,0,0)),
comp_65=  bubble(p, p+float3(-1,0,0))
comp_66=  ),
comp_67=  min(
comp_68=  bubble(p, p+float3(0,0,1)),
comp_69=  bubble(p, p+float3(0,0,-1))
comp_70=  )
comp_71=  )
comp_72=  );
comp_73=  #else
comp_74=  return
comp_75=  min(
comp_76=  bubble(p, p),
comp_77=  min(
comp_78=  bubble(p, p+.5*rd),
comp_79=  bubble(p, p+rd)
comp_80=  )
comp_81=  );
comp_82=  #endif
comp_83=
comp_84=}
comp_85=
comp_86=shader_body {
comp_87=  float4 fragColor = 0;
comp_88=  float2 fragCoord  = uv;
comp_89=  // CONV: Center on screen, then try some aspect correction
comp_90=  uv = (uv*2) - 1;
comp_91=  uv *= aspect.xy;
comp_92=  // CONV: Adjust this to flip the output (±uv.x, ±uv.y)
comp_93=  uv = float2(uv.x, -uv.y);
comp_94=
comp_95=  // float2 uv = (2. * fragCoord-uv.xy)/uv.y;
comp_96=
comp_97=  float3 color = float3(0, 0, 0);
comp_98=
comp_99=  float focal = 2.;
comp_100=  float3 ro = float3(0,0.3+.5*sin(time*.3),4);
comp_101=  float3 rd = normalize(float3(uv, -focal));
comp_102=
comp_103=  float angle_h = (mouse.z > 0) ? ((mouse.x - 0.5) * 2.0 * 3.14159265): time * 0.2;  
comp_104=  float c = cos(angle_h), s = sin(angle_h);
comp_105=  ro.xz = mul(ro.xz, transpose(float2x2(c,s,-s,c)));
comp_106=  rd.xz = mul(rd.xz, transpose(float2x2(c,s,-s,c)));
comp_107=
comp_108=  float angle_v = (mouse.z > 0) ? (mouse.y - 0.5) + c : c;
comp_109=  c = cos(angle_v), s = sin(angle_v);
comp_110=  ro.yz = mul(ro.yz, transpose(float2x2(c,s,-s,c)));
comp_111=  rd.yz = mul(rd.yz, transpose(float2x2(c,s,-s,c)));
comp_112=
comp_113=  float t = 0.;
comp_114=  for(int i = 0; i < 120; i++)
comp_115=  {
comp_116=    float3 p = rd * t + ro;
comp_117=
comp_118=    float3 jelly_hull_pos = float3(0, sin(-time*2.5)*.05, 0);
comp_119=    float jelly_hull_size =  1.-sin(-time*2.5)*.1;
comp_120=
comp_121=    float jelly_hull  = length(p-jelly_hull_pos)-jelly_hull_size;
comp_122=    float jelly_hole1 = length(p-float3(0,cos(-time*2.5)*.05-.85,0))-1.4-sin(time*2.5)*.1;
comp_123=    float jelly_hole2 = length(p-float3(0,cos(-time*2.5)*.05,0))-.7-sin(time*2.5)*.1;
comp_124=
comp_125=    float jelly_sdf = jelly_hull;
comp_126=    jelly_sdf = smax(jelly_sdf, -jelly_hole1);
comp_127=    jelly_sdf = smax(jelly_sdf, -jelly_hole2);
comp_128=    jelly_sdf += .008*cos(10. * atan2(p.z, p.x))*length(p.xz);
comp_129=
comp_130=    float bubbles_sdf = bubbles(p, rd);
comp_131=
comp_132=    float sdf = min(jelly_sdf, bubbles_sdf);
comp_133=
comp_134=    float3 jelly_color = lerp(float3(.2,.525,.85), float3(.1,.6,.7), max(1.-length(p.xz), 0.));
comp_135=    color +=
comp_136=    exp(-.0001*t*t*t) * jelly_color * .025/(.0175 + sqrt(abs(jelly_sdf * jelly_sdf *jelly_sdf)));
comp_137=
comp_138=    #if 0
comp_139=    float3 q = normalize(p-jelly_hull_pos)*jelly_hull_size;
comp_140=    float3 grad = q
comp_141=    float f = smoothstep( 0.01, 0.1, length(q*5.-round(q*5.))/5.);
comp_142=
comp_143=    color += smoothstep(.1, .15, p.y) *
comp_144=    exp(-.0001*t*t*t) *exp(-.2*dot(p-q, p-q)) * 3. * .01/(.0175 + (abs(f)));
comp_145=    #endif
comp_146=
comp_147=    float3 bubble_color = float3(0.3, 0.7, 0.8);
comp_148=    color +=
comp_149=    exp(-.0001*t*t*t) * bubble_color * .025/(.0175 + sqrt(abs(bubbles_sdf)));
comp_150=
comp_151=    float lines_sdf = 9e9;
comp_152=    const float PI = 3.14159265;
comp_153=    for(float j = 1.; j <= 5.; j++)
comp_154=    {
comp_155=      float angle = (2.*PI)/(sqrt(5.)*.5+.5);
comp_156=      float2 dir = float2(cos(j * angle), sin(j*angle));
comp_157=      float2 line_pos = .75*(.11+.5*(j/5.))*dir;
comp_158=
comp_159=      line_pos += smoothstep(0.2, -3., p.y)*sin(j+p.y*5.+time)*.1*dir.yx;
comp_160=
comp_161=      float line_sdf = max(length(p.xz-line_pos), p.y-.8)-(2.0+.75*sin(15.*p.y) + .25*cos(5.*p.y))*.01;
comp_162=      float3 line_color = float3(0.3, 0.7, 0.8);
comp_163=      color +=
comp_164=      exp(-.35*dot(p,p)) * exp(-.0001*t*t*t) * line_color * .025/(.0175 + abs(line_sdf));
comp_165=
comp_166=      lines_sdf = min(lines_sdf, line_sdf);
comp_167=    }
comp_168=
comp_169=    sdf = smin(sdf, lines_sdf);
comp_170=
comp_171=    t += min(.5*abs(sdf) + 1e-4, .5);
comp_172=    if(t > 1e2) j=5;
comp_173=  }
comp_174=
comp_175=  color *= 1./120.;
comp_176=
comp_177=  color *= 1.-.09*length(uv);
comp_178=  color = tanh(color);
comp_179=  color = sRGBencode(color);
comp_180=
comp_181=  // react to audio: jelly color
comp_182=  float fac = 0.8;
comp_183=  #ifdef bass_smooth
comp_184=  if (vis_version == 1) {
comp_185=    fac = 1-clamp(0,2,bass_smooth)*0.4;
comp_186=  }
comp_187=
comp_188=  else if (vis_version == 2) {
comp_189=    fac = 0.9-smoothstep(0,2,bass_att)*0.2;
comp_190=  }
comp_191=
comp_192=  fac = fac*vis_intensity+vis_shift;
comp_193=  #endif
comp_194=  color.g *= fac;
comp_195=
comp_196=  fragColor = float4(color, 1);
comp_197=  ret = fragColor;
comp_198=}
