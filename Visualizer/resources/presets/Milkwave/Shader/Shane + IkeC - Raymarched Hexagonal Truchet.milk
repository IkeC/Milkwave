MILKDROP_PRESET_VERSION=201
PSVERSION=4
PSVERSION_WARP=4
PSVERSION_COMP=4
comp_1=// Shane + IkeC - Raymarched Hexagonal Truchet / https://www.shadertoy.com/view/4td3zj
comp_2=// Transpiled to HLSL using Milkwave
comp_3=
comp_4=#define tx sin(time)*0.5+1
comp_5=
comp_6=// CONV: adding helper functions
comp_7=float mod_conv(float x, float y) { return x - y * floor(x / y); }
comp_8=float2 mod_conv(float2 x, float2 y) { return x - y * floor(x / y); }
comp_9=float3 mod_conv(float3 x, float3 y) { return x - y * floor(x / y); }
comp_10=float4 mod_conv(float4 x, float4 y) { return x - y * floor(x / y); }
comp_11=
comp_12=float heightMap(in float2 p) {
comp_13=
comp_14=p *= 3.;
comp_15=
comp_16=float2 h = float2(p.x + p.y*.57735, p.y*1.1547);
comp_17=
comp_18=float2 fh = floor(h);
comp_19=float2 f = h - fh; h = fh;
comp_20=float c = frac((h.x + h.y)/3.);
comp_21=h =  c<.666 ?   c<.333 ?  h  :  h + 1.  :  h  + step(f.yx, f);
comp_22=
comp_23=p -= float2(h.x - h.y*.5, h.y*.8660254);
comp_24=
comp_25=c = frac(cos(dot(h, float2(41, 289)))*43758.5453); // Reusing "c."
comp_26=p -= p*step(c, .5)*2.; // Equivalent to: if (c<.5) p *= -1.;
comp_27=
comp_28=p -= float2(-1, 0);
comp_29=c = dot(p, p); // Reusing "c" again.
comp_30=p -= float2(1.5, .8660254);
comp_31=c = min(c, dot(p, p));
comp_32=p -= float2(0, -1.73205);
comp_33=c = min(c, dot(p, p));
comp_34=
comp_35=return sqrt(c);
comp_36=
comp_37=}
comp_38=
comp_39=float map(float3 p){
comp_40=
comp_41=float c = heightMap(p.xy); // Height map.
comp_42=c = cos(c*6.2831589) + cos(c*6.2831589*2.);
comp_43=c = (clamp(c*.6 +.5, 0., 1.));
comp_44=
comp_45=return 1. - p.z - c*.025;
comp_46=
comp_47=}
comp_48=
comp_49=float3 getNormal(float3 p, inout float edge, inout float crv) {
comp_50=
comp_51=float2 e = float2(.01, 0); // Larger epsilon for greater sample spread, thus thicker edges.
comp_52=
comp_53=float d1 = map(p + e.xyy), d2 = map(p - e.xyy);
comp_54=float d3 = map(p + e.yxy), d4 = map(p - e.yxy);
comp_55=float d5 = map(p + e.yyx), d6 = map(p - e.yyx);
comp_56=float d = map(p)*2.;	// The hit point itself - Doubled to cut down on calculations. See below.
comp_57=
comp_58=edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);
comp_59=
comp_60=edge = smoothstep(0., 1., sqrt(edge/e.x*2.));
comp_61=
comp_62=crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .6, 0., 1.);
comp_63=
comp_64=e = float2(.0025, 0);
comp_65=d1 = map(p + e.xyy), d2 = map(p - e.xyy);
comp_66=d3 = map(p + e.yxy), d4 = map(p - e.yxy);
comp_67=d5 = map(p + e.yyx), d6 = map(p - e.yyx);
comp_68=
comp_69=return normalize(float3(d1 - d2, d3 - d4, d5 - d6));
comp_70=}
comp_71=
comp_72=float calculateAO(in float3 p, in float3 n)
comp_73={
comp_74=float sca = 2., occ = 0.;
comp_75=for(float i=0.; i<5.; i++){
comp_76=
comp_77=float hr = .01 + i*.5/4.;
comp_78=float dd = map(n * hr + p);
comp_79=occ += (hr - dd)*sca;
comp_80=sca *= 0.7;
comp_81=}
comp_82=return clamp(1.0 - occ, 0., 1.);
comp_83=}
comp_84=
comp_85=float n3D(float3 p){
comp_86=
comp_87=const float3 s = float3(7, 157, 113);
comp_88=float3 ip = floor(p); p -= ip;
comp_89=float4 h = float4(0., s.yz, s.y + s.z) + dot(ip, s);
comp_90=p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);
comp_91=h = lerp(frac(sin(mod_conv(h, 6.2831589))*43758.5453),
comp_92=frac(sin(mod_conv(h + s.x, 6.2831589))*43758.5453), p.x);
comp_93=h.xy = lerp(h.xz, h.yw, p.y);
comp_94=return lerp(h.x, h.y, p.z); // Range: [0, 1].
comp_95=}
comp_96=
comp_97=float3 envMap(float3 rd, float3 sn){
comp_98=
comp_99=float3 sRd = rd; // Save rd, just for some mixing at the end.
comp_100=
comp_101=rd.xy -= time*.25;
comp_102=rd *= 3.;
comp_103=
comp_104=float c = n3D(rd)*.57 + n3D(rd*2.)*.28 + n3D(rd*4.)*.15; // Noise value.
comp_105=c = smoothstep(.4, 1., c); // Darken and add contast for more of a spotlight look.
comp_106=
comp_107=float3 col = float3(c, c*c, c*c*c*c); // Simple, warm coloring.
comp_108=
comp_109=return lerp(col, col.yzx, sRd*.25+.25);
comp_110=
comp_111=}
comp_112=
comp_113=float2 hash22(float2 p) {
comp_114=
comp_115=float n = sin(mod_conv(dot(p, float2(41, 289)), 6.2831589));
comp_116=return frac(float2(262144, 32768)*n)*.75 + .25;
comp_117=
comp_118=}
comp_119=
comp_120=float Voronoi(in float2 p){
comp_121=
comp_122=float2 g = floor(p), o; p -= g;
comp_123=
comp_124=float3 d = float3(1, 1, 1); // 1.4, etc. "d.z" holds the distance comparison value.
comp_125=
comp_126=for(int y = -1; y <= 1; y++){
comp_127=for(int x = -1; x <= 1; x++){
comp_128=
comp_129=o = float2(x, y);
comp_130=o += hash22(g + o) - p;
comp_131=
comp_132=d.z = dot(o, o);
comp_133=
comp_134=d.y = max(d.x, min(d.y, d.z));
comp_135=d.x = min(d.x, d.z);
comp_136=
comp_137=}
comp_138=}
comp_139=
comp_140=return max(d.y/1.2 - d.x*1., 0.)/1.2;
comp_141=
comp_142=}
comp_143=
comp_144=
comp_145=shader_body {
comp_146=float4 fragColor = 0;
comp_147=// CONV: Center on screen, then try some aspect correction
comp_148=//uv = (uv*2) - 1;
comp_149=
comp_150=float2 fragCoord  = uv;
comp_151=fragCoord.y -= 0.2;
comp_152=uv.y += 0.5;
comp_153=uv.x += 0.5;
comp_154=//uv *= aspect.xy;
comp_155=// CONV: Adjust this to flip the output (±uv.x, ±uv.y)
comp_156=//uv = float2(uv.x, -uv.y);
comp_157=
comp_158=
comp_159=
comp_160=// Unit directional ray - Coyote's observation.
comp_161=float3 rd = normalize(float3(3.*fragCoord - uv.xy, uv.y));
comp_162=
comp_163=float tm = time/2.;
comp_164=// Rotate the XY-plane back and forth. Note that sine and cosine are kind of rolled into one.
comp_165=float fac = sin(time*0.11)*0.4+1.2;
comp_166=float2 a = sin(float2(1.570796, 0) + sin(tm/4.)*.3); // Fabrice's observation.
comp_167=rd.xy = mul(transpose(float2x2(a, -a.y, a.x)),rd.xy);
comp_168=
comp_169=// Ray origin. Moving in the X-direction to the right.
comp_170=float3 ro = 0.1*fac*float3(tm, cos(tm/4.), 0.5);
comp_171=
comp_172=
comp_173=// Light position, hovering around behind the camera.
comp_174=float3 lp = ro + float3(cos(tm/2.)*.5, sin(tm/2.)*.5, -.5);
comp_175=
comp_176=// Standard raymarching segment. Because of the straight forward setup, not many iterations are necessary.
comp_177=float d, t=0.;
comp_178=for(int j=0;j<32;j++){
comp_179=
comp_180=d = map(ro + rd*t); // distance to the function.
comp_181=t += d*.7; // Total distance from the camera to the surface.
comp_182=
comp_183=// The plane "is" the far plane, so no "far = plane" break is needed.
comp_184=// CONV: break unsupported, see Milkwave manual
comp_185=if(d<0.001) j=32;
comp_186=
comp_187=}
comp_188=
comp_189=// Edge and curve value. Passed into, and set, during the normal calculation.
comp_190=float edge=0, crv=0;
comp_191=
comp_192=// Surface postion, surface normal and light direction.
comp_193=float3 sp = ro + rd*t;
comp_194=float3 sn = getNormal(sp, edge, crv);
comp_195=float3 ld = lp - sp;
comp_196=
comp_197=
comp_198=
comp_199=// Coloring and texturing the surface.
comp_200=//
comp_201=// Height map.
comp_202=float c = heightMap(sp.xy);
comp_203=
comp_204=// Folding, or wrapping, the values above to produce the snake-like pattern that lines up with the randomly
comp_205=// flipped hex cells produced by the height map.
comp_206=float3 fold = cos(float3(1, 2, 4)*c*6.2831589);
comp_207=
comp_208=// Using the height map value, then wrapping it, to produce a finer grain Truchet pattern for the overlay.
comp_209=float c2 = heightMap((sp.xy + sp.z*.025)*6.);
comp_210=c2 = cos(c2*6.2831589*3.);
comp_211=c2 = (clamp(c2 +.5, 0., 1.));
comp_212=
comp_213=
comp_214=// Function based bump mapping. I prefer none in this example, but it's there if you want it.
comp_215=//if(temp.x>0. || temp.y>0.) sn = dbF(sp, sn, .001);
comp_216=
comp_217=// Surface color value.
comp_218=float3 oC = float3(1, 1, 1);
comp_219=
comp_220=if(fold.x>0.) oC = float3(1, .05, .1)*c2; // Reddish pink with finer grained Truchet overlay.
comp_221=
comp_222=if(fold.x<0.05 && (fold.y)<0.) oC = float3(1, .7, .45)*(c2*.25 + .75); // Lighter lined borders.
comp_223=else if(fold.x<0.) oC = float3(1, .8, .4)*c2; // Gold, with overlay.
comp_224=
comp_225=//oC *= n3D(sp*128.)*.35 + .65; // Extra fine grained noisy texturing.
comp_226=
comp_227=
comp_228=// Sending some greenish particle pulses through the snake-like patterns. With all the shininess going
comp_229=// on, this effect is a little on the subtle side.
comp_230=float p1 = 1.0 - smoothstep(0., .1, fold.x*.5+.5); // Restrict to the snake-like path.
comp_231=// Other path.
comp_232=//float p2 = 1.0 - smoothstep(0., .1, cos(heightMap(sp.xy + 1. + time/4.)*6.283)*.5+.5);
comp_233=float p2 = 1.0 - smoothstep(0., .1, Voronoi(sp.xy*4. + float2(tm, cos(tm/4.))));
comp_234=p1 = (p2 + .25)*p1; // Overlap the paths.
comp_235=oC += oC.yxz*p1*p1; // Gives a kind of electron effect. Works better with just Voronoi, but it'll do.
comp_236=
comp_237=
comp_238=
comp_239=
comp_240=float lDist = max(length(ld), 0.001); // Light distance.
comp_241=float atten = 1./(1. + lDist*.125); // Light attenuation.
comp_242=
comp_243=ld /= lDist; // Normalizing the light direction vector.
comp_244=
comp_245=float diff = max(dot(ld, sn), 0.); // Diffuse.
comp_246=float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 16.); // Specular.
comp_247=float fre = pow(clamp(dot(sn, rd) + 1., .0, 1.), 3.); // Fresnel, for some mild glow.
comp_248=
comp_249=// Shading. Note, there are no actual shadows. The camera is front on, so the following
comp_250=// two functions are enough to give a shadowy appearance.
comp_251=crv = crv*.9 + .1; // Curvature value, to darken the crevices.
comp_252=float ao = calculateAO(sp, sn); // Ambient occlusion, for self shadowing.
comp_253=
comp_254=
comp_255=
comp_256=// Combining the terms above to light the texel.
comp_257=float3 col = oC*(diff + .5) + float3(1., .7, .4)*spec*2. + float3(.4, .7, 1)*fre;
comp_258=
comp_259=col += (oC*.5+.5)*envMap(reflect(rd, sn), sn)*6.; // Fake environment mapping.
comp_260=
comp_261=
comp_262=// Edges.
comp_263=col *= 1. - edge*.85; // Darker edges.
comp_264=
comp_265=// Applying the shades.
comp_266=col *= (atten*crv*ao);
comp_267=
comp_268=
comp_269=// Rough gamma correction, then present to the screen.
comp_270=fragColor = float4(sqrt(clamp(col, 0., 1.)), 1.);
comp_271=ret = fragColor;
comp_272=}
