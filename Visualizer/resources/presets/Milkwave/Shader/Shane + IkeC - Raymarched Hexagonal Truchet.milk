MILKDROP_PRESET_VERSION=201
PSVERSION=4
PSVERSION_WARP=4
PSVERSION_COMP=4
comp_1=// Shane + IkeC - Raymarched Hexagonal Truchet / https://www.shadertoy.com/view/4td3zj
comp_2=// Transpiled to HLSL using Milkwave
comp_3=
comp_4=#define tx sin(time)*0.5+1
comp_5=#define LOOPS 16
comp_6=
comp_7=// CONV: adding helper functions
comp_8=float mod_conv(float x, float y) { return x - y * floor(x / y); }
comp_9=float2 mod_conv(float2 x, float2 y) { return x - y * floor(x / y); }
comp_10=float3 mod_conv(float3 x, float3 y) { return x - y * floor(x / y); }
comp_11=float4 mod_conv(float4 x, float4 y) { return x - y * floor(x / y); }
comp_12=
comp_13=float heightMap(in float2 p) {
comp_14=
comp_15=  p *= 3.;
comp_16=
comp_17=  float2 h = float2(p.x + p.y*.57735, p.y*1.1547);
comp_18=
comp_19=  float2 fh = floor(h);
comp_20=  float2 f = h - fh; h = fh;
comp_21=  float c = frac((h.x + h.y)/3.);
comp_22=  h =  c<.666 ?   c<.333 ?  h  :  h + 1.  :  h  + step(f.yx, f);
comp_23=
comp_24=  p -= float2(h.x - h.y*.5, h.y*.8660254);
comp_25=
comp_26=  c = frac(cos(dot(h, float2(41, 289)))*43758.5453);
comp_27=  // Reusing "c."
comp_28=  p -= p*step(c, .5)*2.;
comp_29=  // Equivalent to: if (c<.5) p *= -1.;
comp_30=
comp_31=  p -= float2(-1, 0);
comp_32=  c = dot(p, p);
comp_33=  // Reusing "c" again.
comp_34=  p -= float2(1.5, .8660254);
comp_35=  c = min(c, dot(p, p));
comp_36=  p -= float2(0, -1.73205);
comp_37=  c = min(c, dot(p, p));
comp_38=
comp_39=  
comp_40=  return sqrt(c);
comp_41=}
comp_42=
comp_43=float map(float3 p){
comp_44=
comp_45=  float c = heightMap(p.xy);
comp_46=  // Height map.
comp_47=  c = cos(c*6.2831589) + cos(c*6.2831589*2.);
comp_48=  c = (clamp(c*.6 +.5, 0., 1.));
comp_49=
comp_50=  return 1. - p.z - c*.025;
comp_51=
comp_52=}
comp_53=
comp_54=float3 getNormal(float3 p, inout float edge, inout float crv) {
comp_55=
comp_56=  float2 e = float2(.01, 0);
comp_57=  // Larger epsilon for greater sample spread, thus thicker edges.
comp_58=
comp_59=  float d1 = map(p + e.xyy), d2 = map(p - e.xyy);
comp_60=  float d3 = map(p + e.yxy), d4 = map(p - e.yxy);
comp_61=  float d5 = map(p + e.yyx), d6 = map(p - e.yyx);
comp_62=  float d = map(p)*2.;
comp_63=  // The hit point itself - Doubled to cut down on calculations. See below.
comp_64=
comp_65=  edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);
comp_66=
comp_67=  edge = smoothstep(0., 1., sqrt(edge/e.x*2.));
comp_68=  
comp_69=  #ifdef bass_smooth
comp_70=    edge *= (int)vis_version > 2 ? 1 : (1.1-0.2*smoothstep(0,2,(int)vis_version == 1 ? bass_smooth : bass_att))*vis_intensity+vis_shift;
comp_71=  #else
comp_72=    edge *= 1.05-0.1*smoothstep(0,2,bass_att);
comp_73=  #endif
comp_74=
comp_75=  crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .6, 0., 1.);
comp_76=
comp_77=  e = float2(.0025, 0);
comp_78=  d1 = map(p + e.xyy), d2 = map(p - e.xyy);
comp_79=  d3 = map(p + e.yxy), d4 = map(p - e.yxy);
comp_80=  d5 = map(p + e.yyx), d6 = map(p - e.yyx);
comp_81=
comp_82=  return normalize(float3(d1 - d2, d3 - d4, d5 - d6));
comp_83=}
comp_84=
comp_85=float calculateAO(in float3 p, in float3 n)
comp_86={
comp_87=  float sca = 2., occ = 0.;
comp_88=  for(float i=0.; i<5.; i++){
comp_89=
comp_90=    float hr = .01 + i*.5/4.;
comp_91=    float dd = map(n * hr + p);
comp_92=    occ += (hr - dd)*sca;
comp_93=    sca *= 0.7;
comp_94=  }
comp_95=
comp_96=  return clamp(1.0 - occ, 0., 1.);
comp_97=}
comp_98=
comp_99=float n3D(float3 p){
comp_100=
comp_101=  const float3 s = float3(7, 157, 113);
comp_102=  float3 ip = floor(p); p -= ip;
comp_103=  float4 h = float4(0., s.yz, s.y + s.z) + dot(ip, s);
comp_104=  p = p*p*(3. - 2.*p);
comp_105=  // p *= p*p*(p*(p * 6. - 15.) + 10.);
comp_106=  h = lerp(frac(sin(mod_conv(h, 6.2831589))*43758.5453),
comp_107=  frac(sin(mod_conv(h + s.x, 6.2831589))*43758.5453), p.x);
comp_108=  h.xy = lerp(h.xz, h.yw, p.y);
comp_109=  return lerp(h.x, h.y, p.z);
comp_110=  // Range: [0, 1].
comp_111=}
comp_112=
comp_113=float3 envMap(float3 rd, float3 sn){
comp_114=
comp_115=  float3 sRd = rd;
comp_116=  // Save rd, just for some mixing at the end.
comp_117=
comp_118=  rd.xy -= time*.25;
comp_119=  rd *= 3.;
comp_120=
comp_121=  float c = n3D(rd)*.57 + n3D(rd*2.)*.28 + n3D(rd*4.)*.15;
comp_122=
comp_123=  // Noise value
comp_124=
comp_125=  #ifdef bass_smooth
comp_126=    float fac = (0.85+0.3*smoothstep(0,2,bass_smooth))*vis_intensity+vis_shift;
comp_127=  #else
comp_128=    float fac = 0.95+0.1*smoothstep(0,2,bass_att);
comp_129=  #endif
comp_130=
comp_131=  c = smoothstep(.4, 1., c*fac);
comp_132=
comp_133=  // Darken and add contast for more of a spotlight look.
comp_134=
comp_135=  float3 col = float3(c, c*c, c*c*c*c);
comp_136=  // Simple, warm coloring.
comp_137=
comp_138=  return lerp(col, col.yzx, sRd*.25+.25);
comp_139=
comp_140=}
comp_141=
comp_142=float2 hash22(float2 p) {
comp_143=
comp_144=  float n = sin(mod_conv(dot(p, float2(41, 289)), 6.2831589));
comp_145=  return frac(float2(262144, 32768)*n)*.75 + .25;
comp_146=
comp_147=}
comp_148=
comp_149=float Voronoi(in float2 p){
comp_150=
comp_151=  float2 g = floor(p), o; p -= g;
comp_152=
comp_153=  float3 d = float3(1, 1, 1);
comp_154=  // 1.4, etc. "d.z" holds the distance comparison value.
comp_155=
comp_156=  for(int y = -1; y <= 1; y++){
comp_157=    for(int x = -1; x <= 1; x++){
comp_158=
comp_159=      o = float2(x, y);
comp_160=      o += hash22(g + o) - p;
comp_161=
comp_162=      d.z = dot(o, o);
comp_163=
comp_164=      d.y = max(d.x, min(d.y, d.z));
comp_165=      d.x = min(d.x, d.z);
comp_166=
comp_167=    }
comp_168=
comp_169=  }
comp_170=  return max(d.y/1.2 - d.x*1., 0.)/1.2;
comp_171=}
comp_172=
comp_173=shader_body {
comp_174=  float4 fragColor = 0;
comp_175=  // CONV: Center on screen, then try some aspect correction
comp_176=  // uv = (uv*2) - 1;
comp_177=
comp_178=  float2 fragCoord  = uv;
comp_179=  fragCoord.y -= 0.2;
comp_180=  uv.y += 0.5;
comp_181=  uv.x += 0.5;
comp_182=  // uv *= aspect.xy;
comp_183=  // CONV: Adjust this to flip the output (±uv.x, ±uv.y)
comp_184=  // uv = float2(uv.x, -uv.y);
comp_185=
comp_186=  // Unit directional ray - Coyote's observation.
comp_187=  float3 rd = normalize(float3(3.*fragCoord - uv.xy, uv.y));
comp_188=
comp_189=  float tm = time/2.;
comp_190=  // Rotate the XY-plane back and forth. Note that sine and cosine are kind of rolled into one.
comp_191=  float fac = sin(time*0.11)*0.4+1.2;
comp_192=  float2 a = sin(float2(1.570796, 0) + sin(tm/4.)*.3);
comp_193=  // Fabrice's observation.
comp_194=  rd.xy = mul(transpose(float2x2(a, -a.y, a.x)),rd.xy);
comp_195=
comp_196=  // Ray origin. Moving in the X-direction to the right.
comp_197=  float3 ro = 0.1*fac*float3(tm, cos(tm/4.), 0.5);
comp_198=
comp_199=  // Light position, hovering around behind the camera.
comp_200=  float3 lp = ro + float3(cos(tm/2.)*.5, sin(tm/2.)*.5, -.5);
comp_201=
comp_202=  // Standard raymarching segment. Because of the straight forward setup, not many iterations are necessary.
comp_203=  float d, t=0.;
comp_204=  
comp_205=  for(int j=0;j<LOOPS;j++){
comp_206=    d = map(ro + rd*t);
comp_207=    // distance to the function.
comp_208=    t += d*.7;
comp_209=    // Total distance from the camera to the surface.
comp_210=
comp_211=    // The plane "is" the far plane, so no "far = plane" break is needed.
comp_212=    // CONV: break unsupported, see Milkwave manual
comp_213=    if(d<0.001) j=LOOPS;
comp_214=  }
comp_215=
comp_216=  // Edge and curve value. Passed into, and set, during the normal calculation.
comp_217=  float edge=0, crv=0;
comp_218=
comp_219=  // Surface postion, surface normal and light direction.
comp_220=  float3 sp = ro + rd*t;
comp_221=  float3 sn = getNormal(sp, edge, crv);
comp_222=  float3 ld = lp - sp;
comp_223=
comp_224=  // Coloring and texturing the surface.
comp_225=  // 
comp_226=  // Height map.
comp_227=  float c = heightMap(sp.xy);
comp_228=
comp_229=  // Folding, or wrapping, the values above to produce the snake-like pattern that lines up with the randomly
comp_230=  // flipped hex cells produced by the height map.
comp_231=  float3 fold = cos(float3(1, 2, 4)*c*6.2831589);
comp_232=
comp_233=  // Using the height map value, then wrapping it, to produce a finer grain Truchet pattern for the overlay.
comp_234=  float c2 = heightMap((sp.xy + sp.z*.025)*6.);
comp_235=  c2 = cos(c2*6.2831589*3.);
comp_236=  c2 = (clamp(c2 +.5, 0., 1.));
comp_237=
comp_238=  // Function based bump mapping. I prefer none in this example, but it's there if you want it.
comp_239=  //if(temp.x>0. || temp.y>0.) sn = dbF(sp, sn, .001);
comp_240=
comp_241=  // Surface color value.
comp_242=  float3 oC = float3(1, 1, 1);
comp_243=
comp_244=  if(fold.x>0.) oC = float3(1, .05, .1)*c2;
comp_245=  // Reddish pink with finer grained Truchet overlay.
comp_246=
comp_247=  if(fold.x<0.05 && (fold.y)<0.) oC = float3(1, .7, .45)*(c2*.25 + .75);
comp_248=  // Lighter lined borders.
comp_249=  else if(fold.x<0.) oC = float3(1, .8, .4)*c2;
comp_250=  // Gold, with overlay.
comp_251=
comp_252=  // oC *= n3D(sp*128.)*.35 + .65; // Extra fine grained noisy texturing.
comp_253=
comp_254=  // Sending some greenish particle pulses through the snake-like patterns. With all the shininess going
comp_255=  // on, this effect is a little on the subtle side.
comp_256=  float p1 = 1.0 - smoothstep(0., .1, fold.x*.5+.5);
comp_257=  // Restrict to the snake-like path.
comp_258=  // Other path.
comp_259=  // float p2 = 1.0 - smoothstep(0., .1, cos(heightMap(sp.xy + 1. + time/4.)*6.283)*.5+.5);
comp_260=  float p2 = 1.0 - smoothstep(0., .1, Voronoi(sp.xy*4. + float2(tm, cos(tm/4.))));
comp_261=  p1 = (p2 + .25)*p1;
comp_262=  // Overlap the paths.
comp_263=  oC += oC.yxz*p1*p1;
comp_264=  // Gives a kind of electron effect. Works better with just Voronoi, but it'll do.
comp_265=
comp_266=  float lDist = max(length(ld), 0.001);
comp_267=  // Light distance.
comp_268=  float atten = 1./(1. + lDist*.125);
comp_269=  // Light attenuation.
comp_270=
comp_271=  ld /= lDist;
comp_272=  // Normalizing the light direction vector.
comp_273=
comp_274=  float diff = max(dot(ld, sn), 0.);
comp_275=  // Diffuse.
comp_276=  float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 16.);
comp_277=  // Specular.
comp_278=  float fre = pow(clamp(dot(sn, rd) + 1., .0, 1.), 3.);
comp_279=  // Fresnel, for some mild glow.
comp_280=
comp_281=  // Shading. Note, there are no actual shadows. The camera is front on, so the following
comp_282=  // two functions are enough to give a shadowy appearance.
comp_283=  crv = crv*.9 + .1;
comp_284=  // Curvature value, to darken the crevices.
comp_285=  float ao = calculateAO(sp, sn);
comp_286=  // Ambient occlusion, for self shadowing.
comp_287=
comp_288=  // Combining the terms above to light the texel.
comp_289=  float3 col = oC*(diff + .5) + float3(1., .7, .4)*spec*2. + float3(.4, .7, 1)*fre;
comp_290=
comp_291=  col += (oC*.5+.5)*envMap(reflect(rd, sn), sn)*6.;
comp_292=  // Fake environment mapping.
comp_293=
comp_294=  // Edges.
comp_295=  col *= 1. - edge*.85;
comp_296=  // Darker edges.
comp_297=
comp_298=  // Applying the shades.
comp_299=  col *= (atten*crv*ao);
comp_300=
comp_301=  // Rough gamma correction, then present to the screen.
comp_302=  fragColor = float4(sqrt(clamp(col, 0., 1.)), 1.);
comp_303=  ret = fragColor;
comp_304=}
