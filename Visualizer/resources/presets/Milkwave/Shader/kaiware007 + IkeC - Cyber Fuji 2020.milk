MILKDROP_PRESET_VERSION=201
PSVERSION=4
PSVERSION_WARP=4
PSVERSION_COMP=4
comp_1=// kaiware007 + IkeC - Cyber Fuji 2020 / https://www.shadertoy.com/view/Wt33Wf
comp_2=// Transpiled to HLSL using Milkwave
comp_3=
comp_4=#define tx sin(time)*0.5+1
comp_5=
comp_6=float mod_conv(float x, float y) { return x - y * floor(x / y); }
comp_7=float2 mod_conv(float2 x, float2 y) { return x - y * floor(x / y); }
comp_8=float3 mod_conv(float3 x, float3 y) { return x - y * floor(x / y); }
comp_9=float4 mod_conv(float4 x, float4 y) { return x - y * floor(x / y); }
comp_10=
comp_11=float sun(float2 uv_conv,  float battery)
comp_12={
comp_13=  float val = smoothstep(0.3, 0.29, length(uv_conv));
comp_14=  float bloom = smoothstep(0.7, 0.0, length(uv_conv));
comp_15=  float cut = 3.0 * sin((uv_conv.y + time * 0.2 * (battery + 0.02)) * 100.0)
comp_16=  + clamp(uv_conv.y * 14.0 + 1.0, -6.0, 6.0);
comp_17=  cut = clamp(cut, 0.0, 1.0);
comp_18=  return clamp(val * cut, 0.0, 1.0) + bloom * 0.6;
comp_19=}
comp_20=
comp_21=float grid(float2 uv_conv,  float battery)
comp_22={
comp_23=  float2 size = float2(uv_conv.y, uv_conv.y * uv_conv.y * 0.2) * 0.01;
comp_24=  uv_conv += float2(0.0, time * 4.0 * (battery + 0.05));
comp_25=  uv_conv = abs(frac(uv_conv) - 0.5);
comp_26=
comp_27=  float2 lines = smoothstep(size, float2(0.0, 0.0), uv_conv);
comp_28=
comp_29=
comp_30=  lines += smoothstep(size * 5.0, float2(0.0, 0.0), uv_conv) * 0.4 * battery;
comp_31=  return clamp(lines.x + lines.y, 0.0, 3.0);
comp_32=}
comp_33=
comp_34=float dot2(in float2 v ) { return dot(v,v); }
comp_35=
comp_36=float sdTrapezoid( in float2 p, in float r1, float r2, float he )
comp_37={
comp_38=  float2 k1 = float2(r2,he);
comp_39=  float2 k2 = float2(r2-r1,2.0*he);
comp_40=  p.x = abs(p.x);
comp_41=  float2 ca = float2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);
comp_42=  float2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );
comp_43=  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;
comp_44=  return s*sqrt( min(dot2(ca),dot2(cb)) );
comp_45=}
comp_46=
comp_47=float sdLine( in float2 p, in float2 a, in float2 b )
comp_48={
comp_49=  float2 pa = p-a, ba = b-a;
comp_50=  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
comp_51=  return length( pa - ba*h );
comp_52=}
comp_53=
comp_54=float sdBox( in float2 p, in float2 b )
comp_55={
comp_56=  float2 d = abs(p)-b;
comp_57=  return length(max(d,float2(0, 0))) + min(max(d.x,d.y),0.0);
comp_58=}
comp_59=
comp_60=float opSmoothUnion(float d1, float d2, float k){
comp_61=  float h = clamp(0.5 + 0.5 * (d2 - d1) /k,0.0,1.0);
comp_62=  return lerp(d2, d1 , h) - k * h * ( 1.0 - h);
comp_63=}
comp_64=
comp_65=float sdCloud(in float2 p, in float2 a1, in float2 b1, in float2 a2, in float2 b2, float w)
comp_66={
comp_67=  // float lineVal1 = smoothstep(w - 0.0001, w, sdLine(p, a1, b1));
comp_68=  
comp_69=  #ifdef bass_smooth
comp_70=    float fac = (int)vis_version > 2 ? 1 : (1-smoothstep(0,2,(int)vis_version == 1 ? bass_smooth : bass_att)*0.2)*vis_intensity+vis_shift;
comp_71=  #else
comp_72=    float fac = 1-smoothstep(0,2,vol_att)*0.1;
comp_73=  #endif
comp_74=
comp_75=  float lineVal1 = fac*sdLine(p, a1, b1);
comp_76=  float lineVal2 = fac*sdLine(p, a2, b2);
comp_77=  float2 ww = float2(w*1.5, 0.0);
comp_78=  float2 left = max(a1 + ww, a2 + ww);
comp_79=  float2 right = min(b1 - ww, b2 - ww);
comp_80=  float2 boxCenter = (left + right) * 0.5;
comp_81=  // float boxW = right.x - left.x;
comp_82=  float boxH = abs(a2.y - a1.y) * 0.5;
comp_83=  // float boxVal = sdBox(p - boxCenter, float2(boxW, boxH)) + w;
comp_84=  float boxVal = sdBox(p - boxCenter, float2(0.04, boxH)) + w;
comp_85=
comp_86=  float uniVal1 = opSmoothUnion(lineVal1, boxVal, 0.05);
comp_87=  float uniVal2 = opSmoothUnion(lineVal2, boxVal, 0.05);
comp_88=
comp_89=  return min(uniVal1, uniVal2);
comp_90=}
comp_91=
comp_92=shader_body {
comp_93=  float4 fragColor;
comp_94=  float2 fragCoord;
comp_95=  // CONV: Center on screen, then try some aspect correction
comp_96=  uv = (uv*2) - 1;
comp_97=  uv *= aspect.xy;
comp_98=  // CONV: Adjust this to flip the output (±uv.x, ±uv.y)
comp_99=  uv = float2(uv.x, -uv.y);
comp_100=
comp_101=  // float2 uv = (2.0 * fragCoord.xy - texsize.xy)/texsize.y;
comp_102=  float battery = 1.0;
comp_103=  // CONV: iMouse unsupported
comp_104=  // //if (iMouse.x > 1.0 && iMouse.y > 1.0) battery = iMouse.y / texsize.y;
comp_105=  // else battery = 0.8;
comp_106=
comp_107=  // if (abs(uv.x) < (9.0 / 16.0))
comp_108=  {
comp_109=    // Grid
comp_110=    float fog = smoothstep(0.1, -0.02, abs(uv.y + 0.2));
comp_111=    float3 col = float3(0.0, 0.1, 0.2);
comp_112=    if (uv.y < -0.2)
comp_113=    {
comp_114=      uv.y = 3.0 / (abs(uv.y + 0.2) + 0.05);
comp_115=      uv.x *= uv.y * 1.0;
comp_116=      float gridVal = grid(uv, battery);
comp_117=      col = lerp(col, float3(1.0, 0.5, 1.0), gridVal);
comp_118=    }
comp_119=
comp_120=    else
comp_121=    {
comp_122=      float fujiD = min(uv.y * 4.5 - 0.5, 1.0);
comp_123=      uv.y -= battery * 1.1 - 0.51;
comp_124=
comp_125=      float2 sunUV = uv;
comp_126=      float2 fujiUV = uv;
comp_127=
comp_128=      // Sun
comp_129=      sunUV += float2(0.75, 0.2);
comp_130=      // uv.y -= 1.1 - 0.51;
comp_131=      col = float3(1.0, 0.2, 1.0);
comp_132=      float sunVal = sun(sunUV, battery);
comp_133=
comp_134=      col = lerp(col, float3(1.0, 0.4, 0.1), sunUV.y * 2.0 + 0.2);
comp_135=      col = lerp(float3(0.0, 0.0, 0.0), col, sunVal);
comp_136=
comp_137=      // fuji
comp_138=      float fujiVal = sdTrapezoid( uv  + float2(-0.75+sunUV.y * 0.0, 0.5), 1.75 + pow(uv.y * uv.y, 2.1), 0.2, 0.5);
comp_139=      float waveVal = uv.y + sin(uv.x * 20.0 + time * 2.0) * 0.05 + 0.2;
comp_140=      float wave_width = smoothstep(0.0,0.01,(waveVal));
comp_141=
comp_142=      // fuji color
comp_143=      col = lerp( col, lerp(float3(0.0, 0.0, 0.25), float3(1.0, 0.0, 0.5), fujiD), step(fujiVal, 0.0));
comp_144=      // fuji top snow
comp_145=      col = lerp( col, float3(1.0, 0.5, 1.0), wave_width * step(fujiVal, 0.0));
comp_146=      // fuji outline
comp_147=      col = lerp( col, float3(1.0, 0.5, 1.0), 1.0-smoothstep(0.0,0.01,abs(fujiVal)) );
comp_148=      // col = lerp( col, float3(1.0, 1.0, 1.0), 1.0-smoothstep(0.03,0.04,abs(fujiVal)) );
comp_149=      // col = float3(1.0, 1.0, 1.0) *(1.0-smoothstep(0.03,0.04,abs(fujiVal)));
comp_150=
comp_151=      // horizon color
comp_152=      col += lerp( col, lerp(float3(1.0, 0.12, 0.8), float3(0.0, 0.0, 0.2), clamp(uv.y * 3.5 + 3.0, 0.0, 1.0)), step(0.0, fujiVal) );
comp_153=
comp_154=      // cloud
comp_155=      float2 cloudUV = uv;
comp_156=      cloudUV.x = mod_conv(cloudUV.x + time * 0.1, 4.0) - 2.0;
comp_157=      float cloudTime = time * 0.5;
comp_158=      float cloudY = -0.5;
comp_159=      float cloudVal1 = sdCloud(cloudUV,
comp_160=      float2(0.1 + sin(cloudTime + 140.5)*0.1,cloudY),
comp_161=      float2(1.05 + cos(cloudTime * 0.9 - 36.56) * 0.1, cloudY),
comp_162=      float2(0.2 + cos(cloudTime * 0.867 + 387.165) * 0.1,0.25+cloudY),
comp_163=      float2(0.5 + cos(cloudTime * 0.9675 - 15.162) * 0.09, 0.25+cloudY), 0.075);
comp_164=      cloudY = -0.6;
comp_165=      float cloudVal2 = sdCloud(cloudUV,
comp_166=      float2(-0.9 + cos(cloudTime * 1.02 + 541.75) * 0.1,cloudY),
comp_167=      float2(-0.5 + sin(cloudTime * 0.9 - 316.56) * 0.1, cloudY),
comp_168=      float2(-1.5 + cos(cloudTime * 0.867 + 37.165) * 0.1,0.25+cloudY),
comp_169=      float2(-0.6 + sin(cloudTime * 0.9675 + 665.162) * 0.09, 0.25+cloudY), 0.075);
comp_170=
comp_171=      float cloudVal = min(cloudVal1, cloudVal2);
comp_172=
comp_173=      // col = lerp(col, float3(1.0,1.0,0.0), smoothstep(0.0751, 0.075, cloudVal));
comp_174=      col = lerp(col, float3(0.0, 0.0, 0.2), 1.0 - smoothstep(0.075 - 0.0001, 0.075, cloudVal));
comp_175=      col += float3(1.0, 1.0, 1.0)*(1.0 - smoothstep(0.0,0.01,abs(cloudVal - 0.075)));
comp_176=    }
comp_177=
comp_178=    col += fog * fog * fog;
comp_179=    col = lerp(float3(col.r, col.r, col.r) * 0.5, col, battery * 0.7);
comp_180=
comp_181=    ret = float4(col,1.0);
comp_182=  }
comp_183=
comp_184=  // else ret = float4(0.0, 0.0, 0.0, 0.0);
comp_185=
comp_186=}
