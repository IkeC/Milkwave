MILKDROP_PRESET_VERSION=201
PSVERSION=4
PSVERSION_WARP=4
PSVERSION_COMP=4
comp_1=// Kali + IkeC - Fractal Land / https://www.shadertoy.com/view/XsBXWt
comp_2=// Transpiled to HLSL using Milkwave
comp_3=
comp_4=#define tx (sin(time)*0.5+1)
comp_5=
comp_6=// CONV: setting iChannel samplers to default noise texture
comp_7=#define iChannel0 sampler_noise_lq
comp_8=#define iChannel1 sampler_stoy_nyancat
comp_9=
comp_10=sampler sampler_stoy_nyancat;
comp_11=
comp_12=// CONV: adding helper functions
comp_13=float mod_conv(float x, float y) { return x - y * floor(x / y); }
comp_14=float2 mod_conv(float2 x, float2 y) { return x - y * floor(x / y); }
comp_15=float3 mod_conv(float3 x, float3 y) { return x - y * floor(x / y); }
comp_16=float4 mod_conv(float4 x, float4 y) { return x - y * floor(x / y); }
comp_17=
comp_18=#define NYAN
comp_19=#define WAVES
comp_20=
comp_21=// #define BORDER
comp_22=
comp_23=#define RAY_STEPS 150
comp_24=
comp_25=#define BRIGHTNESS 1.2
comp_26=#define GAMMA 1.4
comp_27=#define SATURATION .65
comp_28=
comp_29=#define detail .001
comp_30=#define t time*.5
comp_31=
comp_32=float det=0.0;
comp_33=
comp_34=float2x2 rot(float a) {
comp_35=  return float2x2(cos(a),sin(a),-sin(a),cos(a));
comp_36=}
comp_37=
comp_38=float4 formula(float4 p) {
comp_39=  p.xz = abs(p.xz+1.)-abs(p.xz-1.)-p.xz;
comp_40=  p.y-=.25;
comp_41=  p.xy = mul(p.xy, rot(radians(35.)));
comp_42=  p=p*2./clamp(dot(p.xyz,p.xyz),.2,1.);
comp_43=  return p;
comp_44=}
comp_45=
comp_46=float de(float3 pos) {
comp_47=  #ifdef WAVES
comp_48=  pos.y+=sin(pos.z-t*6.)*.15;
comp_49=  // waves!
comp_50=  #endif
comp_51=  float hid=0.;
comp_52=  float3 tpos=pos;
comp_53=  tpos.z=abs(3.-mod_conv(tpos.z,6.));
comp_54=  float4 p=float4(tpos,1.);
comp_55=  for (int i=0; i<4; i++) {p=formula(p);}
comp_56=  float fr=(length(max(float2(0., 0.),p.yz-1.5))-1.)/p.w;
comp_57=  float ro=max(abs(pos.x+1.)-.3,pos.y-.35);
comp_58=  ro=max(ro,-max(abs(pos.x+1.)-.1,pos.y-.5));
comp_59=  pos.z=abs(.25-mod_conv(pos.z,.5));
comp_60=  ro=max(ro,-max(abs(pos.z)-.2,pos.y-.3));
comp_61=  ro=max(ro,-max(abs(pos.z)-.01,-pos.y+.32));
comp_62=  float d=min(fr,ro);
comp_63=  return d;
comp_64=}
comp_65=
comp_66=float3 path(float ti) {
comp_67=  ti*=1.5;
comp_68=  float3  p=float3(sin(ti),(1.-sin(ti*2.))*.5,-ti*5.)*.5;
comp_69=  return p;
comp_70=}
comp_71=
comp_72=float edge=0.;
comp_73=float3 normal(float3 p) {
comp_74=  float3 e = float3(0.0,det*5.,0.0);
comp_75=
comp_76=  float d1=de(p-e.yxx),d2=de(p+e.yxx);
comp_77=  float d3=de(p-e.xyx),d4=de(p+e.xyx);
comp_78=  float d5=de(p-e.xxy),d6=de(p+e.xxy);
comp_79=  float d=de(p);
comp_80=  edge=abs(d-0.5*(d2+d1))+abs(d-0.5*(d4+d3))+abs(d-0.5*(d6+d5));
comp_81=  // edge finder
comp_82=  edge=min(1.,pow(edge,.55)*15.);
comp_83=  return normalize(float3(d1-d2,d3-d4,d5-d6));
comp_84=}
comp_85=
comp_86=float4 rainbow(float2 p)
comp_87={
comp_88=  float q = max(p.x,-0.1);
comp_89=  float s = sin(p.x*7.0+t*70.0)*0.08;
comp_90=  p.y+=s;
comp_91=  p.y*=1.1;
comp_92=
comp_93=  float4 c;
comp_94=  if (p.x>0.0) c=float4(0,0,0,0); else
comp_95=  if (0.0/6.0<p.y&&p.y<1.0/6.0) c= float4(255,43,14,255)/255.0; else
comp_96=  if (1.0/6.0<p.y&&p.y<2.0/6.0) c= float4(255,168,6,255)/255.0; else
comp_97=  if (2.0/6.0<p.y&&p.y<3.0/6.0) c= float4(255,244,0,255)/255.0; else
comp_98=  if (3.0/6.0<p.y&&p.y<4.0/6.0) c= float4(51,234,5,255)/255.0; else
comp_99=  if (4.0/6.0<p.y&&p.y<5.0/6.0) c= float4(8,163,255,255)/255.0; else
comp_100=  if (5.0/6.0<p.y&&p.y<6.0/6.0) c= float4(122,85,255,255)/255.0; else
comp_101=  if (abs(p.y)-.05<0.0001) c=float4(0.,0.,0.,1.); else
comp_102=  if (abs(p.y-1.)-.05<0.0001) c=float4(0.,0.,0.,1.); else
comp_103=  c=float4(0,0,0,0);
comp_104=  c.a*=.8-min(.8,abs(p.x*.08));
comp_105=  c.xyz=lerp(c.xyz,float3(length(c.xyz), length(c.xyz), length(c.xyz)),.15);
comp_106=  return c;
comp_107=}
comp_108=
comp_109=float4 nyan(float2 p)
comp_110={
comp_111=  float2 uv_conv = p*float2(0.4,1.0);
comp_112=  float ns=3.0;
comp_113=  float nt = time*ns; nt-=mod_conv(nt,240.0/256.0/6.0); nt = mod_conv(nt,240.0/256.0);
comp_114=  float ny = mod_conv(time*ns,1.0); ny-=mod_conv(ny,0.75); ny*=-0.05;
comp_115=  float4 color = tex2D(iChannel1,float2(uv_conv.x/3.0+210.0/256.0-nt+0.05,.5-uv_conv.y-ny));
comp_116=  if (uv_conv.x<-0.3) color.a = 0.0;
comp_117=  if (uv_conv.x>0.2) color.a=0.0;
comp_118=
comp_119=  // crop the bottom cats
comp_120=  if (uv_conv.y<-0.3) color.a = 0.0;
comp_121=  return color;
comp_122=}
comp_123=
comp_124=float3 raymarch(in float3 from, in float3 dir)
comp_125={
comp_126=  edge=0.;
comp_127=  float3 p, norm;
comp_128=  float d=100.;
comp_129=  float totdist=0.;
comp_130=  for (int i=0; i<RAY_STEPS; i++) {
comp_131=    if (d>det*totdist && totdist<25.0) {
comp_132=      p=from+totdist*dir;
comp_133=      d=de(p);
comp_134=      det=detail*exp(.13*totdist);
comp_135=      totdist+=d;
comp_136=    }
comp_137=
comp_138=  }
comp_139=
comp_140=  float3 col=float3(0., 0., 0.);
comp_141=  p-=(det-d)*dir;
comp_142=  norm=normal(p);
comp_143=  #ifdef SHOWONLYEDGES
comp_144=  col=1.-float3(edge);
comp_145=  // show wireframe version
comp_146=  #else
comp_147=  col=(1.-abs(norm))*max(0.,1.-edge*.8);
comp_148=  // set normal as color with dark edges
comp_149=  #endif
comp_150=  totdist=clamp(totdist,0.,26.);
comp_151=  dir.y-=.02;
comp_152=
comp_153=  // float sunsize=7.-max(0.,tex2D(iChannel0,float2(.6,.2)).x)*5.;
comp_154=  // 4.6: very bright, 7.6: small
comp_155=
comp_156=  float sunsize = 7.6;
comp_157=  #ifdef bass_smooth
comp_158=    sunsize -= 2*vis_shift;
comp_159=    if (vis_version ==  1) {
comp_160=      sunsize -= clamp(0,2,bass_smooth)*1.5*vis_intensity;
comp_161=    } else if (vis_version ==  2) {    
comp_162=      sunsize -= smoothstep(0,2,bass_att)*1.4*vis_intensity;
comp_163=    } else {
comp_164=      sunsize -= vis_intensity;
comp_165=    }
comp_166=  #else
comp_167=    sunsize -= smoothstep(0,2,bass_att)*1.4;
comp_168=  #endif
comp_169=
comp_170=  // responsive sun size
comp_171=  float an=atan2(dir.x,dir.y)+time*1.5;
comp_172=  // angle for drawing and rotating sun
comp_173=  float s=pow(clamp(1.0-length(dir.xy)*sunsize-abs(.2-mod_conv(an,.4)),0.,1.),.1);
comp_174=  // sun
comp_175=  float sb=pow(clamp(1.0-length(dir.xy)*(sunsize-.2)-abs(.2-mod_conv(an,.4)),0.,1.),.1);
comp_176=
comp_177=  // sun border
comp_178=  float sg=pow(clamp(1.0-length(dir.xy)*(sunsize-4.5)-.5*abs(.2-mod_conv(an,.4)),0.,1.),3.);
comp_179=
comp_180=  // sun rays
comp_181=  float y=lerp(.45,1.2,pow(smoothstep(0.,1.,.75-dir.y),2.))*(1.-sb*.5);
comp_182=
comp_183=  // gradient sky
comp_184=  float3 backg=float3(0.5,0.,1.)*((1.-s)*(1.-sg)*y+(1.-sb)*sg*float3(1.,.8,0.15)*3.);
comp_185=  backg+=float3(1.,.9,.1)*s;
comp_186=  backg=max(backg,sg*float3(1.,.9,.5));
comp_187=
comp_188=  col=lerp(float3(1.,.9,.3),col,exp(-.004*totdist*totdist));
comp_189=  // distant fading to sun color
comp_190=  if (totdist>25.) col=backg;
comp_191=
comp_192=  // hit background
comp_193=  col=pow(col,float3(GAMMA,GAMMA,GAMMA))*BRIGHTNESS;
comp_194=  col=lerp(float3(length(col), length(col), length(col)),col,SATURATION);
comp_195=
comp_196=  #ifdef SHOWONLYEDGES
comp_197=  col=1.-float3(length(col), length(col), length(col));
comp_198=  #else
comp_199=  col*=float3(1.,.9,.85);
comp_200=  #ifdef NYAN
comp_201=  dir.yx =mul(dir.yx,rot(dir.x));
comp_202=  float2 ncatpos=(dir.xy+float2(-3.+mod_conv(-t,6.),-.27));
comp_203=  float4 ncat=nyan(ncatpos*5.);
comp_204=  float4 rain=rainbow(ncatpos*10.+float2(.8,.5));
comp_205=  if (totdist>8.) col=lerp(col,max(float3(.2,.2,.2),rain.xyz),rain.a*.9);
comp_206=  if (totdist>8.) col=lerp(col,max(float3(.2,.2,.2),ncat.xyz),ncat.a*.9);
comp_207=  #endif
comp_208=  #endif
comp_209=  return col;
comp_210=}
comp_211=
comp_212=float3 move(inout float3 dir) {
comp_213=  float3 go=path(t);
comp_214=  float3 adv=path(t+.7);
comp_215=  float hd=de(adv);
comp_216=  float3 advec=normalize(adv-go);
comp_217=  float an=adv.x-go.x; an*=min(1.,abs(adv.z-go.z))*sign(adv.z-go.z)*.7;
comp_218=  dir.xy = mul(dir.xy, transpose(float2x2(cos(an),sin(an),-sin(an),cos(an))));
comp_219=  an=advec.y*1.7;
comp_220=  dir.yz = mul(dir.yz, transpose(float2x2(cos(an),sin(an),-sin(an),cos(an))));
comp_221=  an=atan2(advec.x,advec.z);
comp_222=  dir.xz = mul(dir.xz, transpose(float2x2(cos(an),sin(an),-sin(an),cos(an))));
comp_223=  return go;
comp_224=}
comp_225=
comp_226=shader_body {
comp_227=  float4 fragColor = 0;
comp_228=  // CONV: Center on screen, then try some aspect correction
comp_229=  uv = (uv*2) - 1;
comp_230=  uv *= aspect.xy;
comp_231=  // CONV: Adjust this to flip the output (±uv.x, ±uv.y)
comp_232=  uv = float2(uv.x, -uv.y);
comp_233=  float2 fragCoord  = uv;
comp_234=
comp_235=  // uv = fragCoord.xy / uv.xy*2.-1.;
comp_236=  float2 oriuv=uv;
comp_237=  // uv.y*=uv.y/uv.x;
comp_238=
comp_239=  // CONV: iMouse unsupported, introducing standard variable
comp_240=  float3 iMouse = float3(0.5, 0.5, 0);
comp_241=  float2 mouse=(iMouse.xy/uv.xy-.5)*3.;
comp_242=  if (iMouse.z<1.) mouse=float2(0.,-0.05);
comp_243=
comp_244=  // "zoom"
comp_245=  float fov=.9-max(0.,.7-time*.3);
comp_246=  float3 dir=normalize(float3(uv*fov,1.));
comp_247=
comp_248=  // dir.yz=mul(dir.yz,rot(mouse.y));
comp_249=  // dir.xz=mul(dir.xz,rot(mouse.x));
comp_250=
comp_251=  float3 origin=float3(-1.,.7,0.);
comp_252=  float3 from=origin+move(dir);
comp_253=
comp_254=  from.x += 2;
comp_255=  from.y += 0.05;
comp_256=
comp_257=  // from.x += -1.1;
comp_258=  // from.y += -0.9;
comp_259=
comp_260=  float3 color=raymarch(from,dir);
comp_261=  #ifdef BORDER
comp_262=  color=lerp(float3(0., 0., 0.),color,pow(max(0.,.95-length(oriuv*oriuv*oriuv*float2(1.05,1.1))),.3));
comp_263=  #endif
comp_264=  fragColor = float4(color,1.);
comp_265=  ret = fragColor;
comp_266=}
