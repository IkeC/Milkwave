MILKDROP_PRESET_VERSION=201
PSVERSION=4
PSVERSION_WARP=4
PSVERSION_COMP=4
comp_1=// edankwan + IkeC - CineShader Lava / https://www.shadertoy.com/view/3sySRK
comp_2=// Transpiled to HLSL using Milkwave
comp_3=
comp_4=#define tx sin(time)*0.5+1
comp_5=
comp_6=float opSmoothUnion( float d1, float d2, float k )
comp_7={
comp_8=  #ifdef bass_smooth
comp_9=    d1 -= (int)vis_version > 2 ? 0.05*vis_intensity+vis_shift : (0.25*(smoothstep(0,2,(int)vis_version == 1 ? bass_smooth : bass_att)))*vis_intensity+vis_shift;
comp_10=  #else
comp_11=    d1 -= 0.05*(smoothstep(0,2,bass_att));
comp_12=  #endif
comp_13=
comp_14=  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );
comp_15=  return lerp( d2, d1, h ) - k*h*(1.0-h);
comp_16=}
comp_17=
comp_18=float sdSphere( float3 p, float s )
comp_19={
comp_20=  return length(p)-s;
comp_21=}
comp_22=
comp_23=float map(float3 p)
comp_24={
comp_25=  float d = 2.0;
comp_26=  for (int i = 0; i < 16; i++) {
comp_27=    float fi = float(i);
comp_28=    float time_conv = time * (frac(fi * 412.531 + 0.513) - 0.5) * 2.0;
comp_29=    d = opSmoothUnion(
comp_30=    sdSphere(p + sin(time_conv + fi * float3(52.5126, 64.62744, 632.25)) * float3(2.0, 2.0, 0.8), lerp(0.5, 1.0, frac(fi * 412.531 + 0.5124))),
comp_31=    d,
comp_32=    0.4
comp_33=    );
comp_34=  }
comp_35=
comp_36=  return d;
comp_37=}
comp_38=
comp_39=float3 calcNormal( in float3 p )
comp_40={
comp_41=  const float h = 1e-5;
comp_42=  // or some other value
comp_43=  const float2 k = float2(1,-1);
comp_44=  return normalize( k.xyy*map( p + k.xyy*h ) +
comp_45=  k.yyx*map( p + k.yyx*h ) +
comp_46=  k.yxy*map( p + k.yxy*h ) +
comp_47=  k.xxx*map( p + k.xxx*h ) );
comp_48=}
comp_49=
comp_50=shader_body {
comp_51=  float4 fragColor;
comp_52=  float2 fragCoord;
comp_53=  // CONV: Center on screen, then try some aspect correction
comp_54=  // uv = (uv*2) - 1;
comp_55=  uv.x *= aspect.x;
comp_56=  // CONV: Adjust this to flip the output (±uv.x, ±uv.y)
comp_57=  // uv = float2(uv.x, -uv.y);
comp_58=
comp_59=  // float2 uv = fragCoord/texsize.xy;
comp_60=
comp_61=  // screen size is 6m x 6m
comp_62=  float3 rayOri = float3((uv - 0.5) * float2(texsize.x/texsize.y, 1.0) * 6.0, 3.0);
comp_63=  float3 rayDir = float3(0.0, 0.0, -1.0);
comp_64=
comp_65=  float depth = 0.0;
comp_66=  float3 p;
comp_67=
comp_68=  for(int i = 0; i < 64; i++) {
comp_69=    p = rayOri + rayDir * depth;
comp_70=    float dist = map(p);
comp_71=    depth += dist;
comp_72=    if (dist < 1e-6) {
comp_73=      // CONV: break is unsupported, see Milkwave manual for details
comp_74=      i=64;
comp_75=    }
comp_76=
comp_77=  }
comp_78=
comp_79=  depth = min(6.0, depth);
comp_80=  float3 n = calcNormal(p);
comp_81=  float b = max(0.0, dot(n, float3(0.577, 0.577, 0.577)));
comp_82=  float3 col = (0.5 + 0.5 * cos((b + time * 3.0) + uv.xyx * 2.0 + float3(0,2,4))) * (0.85 + b * 0.35);
comp_83=  col *= exp( -depth * 0.15 );
comp_84=
comp_85=  // maximum thickness is 2m in alpha channel
comp_86=  ret = float4(col, 1.0 - (depth - 0.5) / 2.0);
comp_87=}
