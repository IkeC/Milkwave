MILKDROP_PRESET_VERSION=201
PSVERSION=4
PSVERSION_WARP=4
PSVERSION_COMP=4
comp_1=// Trixelized + IkeC - Electrocardiogram_Trixy / https://www.shadertoy.com/view/McycDt
comp_2=// Transpiled to HLSL using Milkwave
comp_3=
comp_4=#define PI 3.141
comp_5=
comp_6=shader_body {
comp_7=  float4 fragColor = 0;
comp_8=  float2 fragCoord  = uv;
comp_9=  // CONV: Center on screen, then try some aspect correction
comp_10=  uv = (uv*2) - 1;
comp_11=  uv *= aspect.xy;
comp_12=  // CONV: Adjust this to flip the output (±uv.x, ±uv.y)
comp_13=  uv = float2(uv.x, -uv.y);
comp_14=
comp_15=  // float2 uv = (fragCoord - (0.5 * uv.xy)) / uv.y;
comp_16=
comp_17=  float hei = 0.0;
comp_18=  
comp_19=  // Wobble
comp_20=  hei += sin(uv.x * 42.0) * 0.005;
comp_21=  hei += sin(uv.x * 20.0) * 0.010;
comp_22=  
comp_23=  // Heartbeat
comp_24=  const float hb_size = 0.20;
comp_25=  const float hb_smooth = 0.15;
comp_26=  float hb_mult = smoothstep(
comp_27=  hb_size + hb_smooth,
comp_28=  hb_size - hb_smooth,
comp_29=  abs(uv.x)
comp_30=  );
comp_31=  
comp_32=  float hb_hei = sin(uv.x / hb_size * PI);
comp_33=  hei = lerp(hei, hb_hei, hb_mult);
comp_34=
comp_35=  #ifdef bass_smooth
comp_36=    float fac = (int)vis_version > 2 ? 1*vis_intensity+vis_shift : (0.75 + 0.5*smoothstep(0,2,(int)vis_version == 1 ? bass_smooth : bass_att))*vis_intensity+vis_shift;
comp_37=  #else
comp_38=    float fac = 0.8 + 0.4*smoothstep(0,2,bass_att);
comp_39=  #endif
comp_40=  
comp_41=  hei*=fac;
comp_42=
comp_43=  // Line + glow value
comp_44=  float val = 0.0;
comp_45=  val += smoothstep(
comp_46=  0.010,
comp_47=  0.005,
comp_48=  abs(hei / 3.0 - uv.y)
comp_49=  );
comp_50=  val += smoothstep(
comp_51=  0.125,
comp_52=  -0.1,
comp_53=  abs(hei / 3.0 - uv.y)
comp_54=  );
comp_55=  
comp_56=  // Base color
comp_57=  float anim = (uv.x - time) / 2.0;
comp_58=  float3 col = pow(frac(anim)*val, 1.5)
comp_59=  * float3(0.250, 1.000, 0.250);
comp_60=
comp_61=  // Grid
comp_62=  float grid_x = abs(1.0 - 2.0 * frac(uv.x * 6.0));
comp_63=  float grid_y = abs(1.0 - 2.0 * frac(uv.y * 12.0));
comp_64=  col += smoothstep(0.1, 0.0, min(grid_x, grid_y))
comp_65=  * (uv.y + 0.5)
comp_66=  * float3(0.1, 0.2, 0.2);
comp_67=
comp_68=  // Output to screen
comp_69=  fragColor = float4(col, 1.0);
comp_70=  ret = fragColor;
comp_71=}
