MILKDROP_PRESET_VERSION=201
PSVERSION=4
PSVERSION_WARP=4
PSVERSION_COMP=4
comp_1=// macbooktall + IkeC - fractal trees gif / https://www.shadertoy.com/view/llXfRr
comp_2=// Transpiled to HLSL using Milkwave
comp_3=
comp_4=float mod_conv(float x, float y) { return x - y * floor(x / y); }
comp_5=float2 mod_conv(float2 x, float2 y) { return x - y * floor(x / y); }
comp_6=float3 mod_conv(float3 x, float3 y) { return x - y * floor(x / y); }
comp_7=float4 mod_conv(float4 x, float4 y) { return x - y * floor(x / y); }
comp_8=
comp_9=#define MAXDIST 50.
comp_10=#define iterations 20
comp_11=
comp_12=struct Ray {
comp_13=float3 ro;
comp_14=float3 rd;
comp_15=};
comp_16=
comp_17=float3 hue(float3 color, float shift) {
comp_18=
comp_19=const float3  kRGBToYPrime = float3 (0.299, 0.587, 0.114);
comp_20=const float3  kRGBToI     = float3 (0.596, -0.275, -0.321);
comp_21=const float3  kRGBToQ     = float3 (0.212, -0.523, 0.311);
comp_22=
comp_23=/*
comp_24=const float3  kRGBToYPrime = float3 (1,1,1);
comp_25=const float3  kRGBToI     = float3 (1,1,1);
comp_26=const float3  kRGBToQ     = float3 (1,1,1);
comp_27=*/
comp_28=
comp_29=
comp_30=const float3  kYIQToR   = float3 (1.0, 0.956, 0.621);
comp_31=const float3  kYIQToG   = float3 (1.0, -0.272, -0.647);
comp_32=const float3  kYIQToB   = float3 (1.0, -1.107, 1.704);
comp_33=/*
comp_34=const float3  kYIQToR   = float3 (11,0,0);
comp_35=const float3  kYIQToG   = float3 (11,0,0);
comp_36=const float3  kYIQToB   = float3 (11,0,0);
comp_37=*/
comp_38=
comp_39=float   YPrime  = dot (color, kRGBToYPrime);
comp_40=float   I      = dot (color, kRGBToI);
comp_41=float   Q      = dot (color, kRGBToQ);
comp_42=
comp_43=float   hue     = atan2 (Q, I);
comp_44=float   chroma  = sqrt (I * I + Q * Q);
comp_45=
comp_46=hue += shift;
comp_47=
comp_48=Q = chroma * sin (hue);
comp_49=I = chroma * cos (hue);
comp_50=
comp_51=float3    yIQ   = float3 (YPrime, I, Q);
comp_52=color.r = dot (yIQ, kYIQToR);
comp_53=color.g = dot (yIQ, kYIQToG);
comp_54=color.b = dot (yIQ, kYIQToB);
comp_55=
comp_56=return color;
comp_57=}
comp_58=
comp_59=float opU( float d1, float d2 )
comp_60={
comp_61=return min(d1,d2);
comp_62=}
comp_63=
comp_64=float smin( float a, float b, float k ){
comp_65=float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );
comp_66=return lerp( b, a, h ) - k*h*(1.0-h);
comp_67=}
comp_68=
comp_69=float length6( float3 p )
comp_70={
comp_71=p = p*p*p; p = p*p;
comp_72=return pow( p.x + p.y + p.z, 1.0/6.0 );
comp_73=}
comp_74=
comp_75=float fPlane(float3 p, float3 n, float distanceFromOrigin) {
comp_76=return dot(p, n) + distanceFromOrigin;
comp_77=}
comp_78=
comp_79=void pR(inout float2 p, float a) {
comp_80=p = cos(a)*p + sin(a)*float2(p.y, -p.x);
comp_81=}
comp_82=
comp_83=float fractal(float3 p)
comp_84={
comp_85=float d = time*5. - p.z;
comp_86=p=p.yxz;
comp_87=pR(p.yz, 1.570795);
comp_88=p.x += 6.5;
comp_89=
comp_90=p.yz = mod_conv(abs(p.yz)-.0, 20.) - 10.;
comp_91=float scale = 1.25;
comp_92=
comp_93=p.xy /= (1.+d*d*0.0005);
comp_94=
comp_95=float l = 0.;
comp_96=
comp_97=for (int i=0; i<iterations; i++) {
comp_98=p.xy = abs(p.xy);
comp_99=p = p*scale + float3(-3. + d*0.0095,-1.5,-.5);
comp_100=
comp_101=pR(p.xy,0.35-d*0.015);
comp_102=pR(p.yz,0.5+d*0.02);
comp_103=
comp_104=l =length6(p);
comp_105=}
comp_106=return l*pow(scale, -float(iterations))-.15;
comp_107=}
comp_108=
comp_109=float2 map(float3 pos)
comp_110={
comp_111=float dist = 10.;
comp_112=dist = opU(dist, fractal(pos));
comp_113=dist = smin(dist, fPlane(pos,float3(0.0,1.0,0.0),10.), 4.6);
comp_114=return float2(dist, 0.);
comp_115=}
comp_116=
comp_117=float3 vmarch(Ray ray, float dist)
comp_118={
comp_119=float3 p = ray.ro;
comp_120=float2 r = float2(0., 0.);
comp_121=float3 sum = float3(0, 0, 0);
comp_122=
comp_123=float3 c = hue(float3(0,0,1),5.5);
comp_124=
comp_125=for( int i=0; i<20; i++ )
comp_126={
comp_127=r = map(p);
comp_128=// CONV: break is unsupported, see Milkwave manual for details
comp_129=if (r.x > .01) i=20;
comp_130=p += ray.rd*.015;
comp_131=float3 col = c;
comp_132=col.rgb *= smoothstep(.0,0.15,-r.x);
comp_133=sum += abs(col)*.5;
comp_134=}
comp_135=return sum;
comp_136=}
comp_137=
comp_138=float2 march(Ray ray)
comp_139={
comp_140=const int steps = 50;
comp_141=const float prec = 0.001;
comp_142=float2 res = float2(0., 0.);
comp_143=
comp_144=for (int i = 0; i < steps; i++)
comp_145={
comp_146=float2 s = map(ray.ro + ray.rd * res.x);
comp_147=
comp_148=if (res.x > MAXDIST || s.x < prec)
comp_149={
comp_150=i=steps;
comp_151=}
comp_152=
comp_153=res.x += s.x;
comp_154=res.y = s.y;
comp_155=
comp_156=}
comp_157=
comp_158=return res;
comp_159=}
comp_160=
comp_161=float3 calcNormal(float3 pos)
comp_162={
comp_163=const float3 eps = float3(0.005, 0.0, 0.0);
comp_164=
comp_165=return normalize(
comp_166=float3(map(pos + eps).x - map(pos - eps).x,
comp_167=map(pos + eps.yxz).x - map(pos - eps.yxz).x,
comp_168=map(pos + eps.yzx).x - map(pos - eps.yzx).x )
comp_169=);
comp_170=}
comp_171=
comp_172=float4 render(Ray ray)
comp_173={
comp_174=// background
comp_175=float3 bgcol = float3(0.7,0,0);
comp_176=
comp_177=float3 col = bgcol;
comp_178=float2 res = march(ray);
comp_179=
comp_180=if (res.x > MAXDIST)
comp_181={
comp_182=return float4(col, 50.);
comp_183=} else {
comp_184=
comp_185=float3 pos = ray.ro+res.x*ray.rd;
comp_186=ray.ro = pos;
comp_187=col = vmarch(ray, res.x);
comp_188=
comp_189=col = lerp(col, bgcol, clamp(res.x/50., 0., 1.));
comp_190=return float4(col, res.x);
comp_191=}
comp_192=}
comp_193=
comp_194=float3x3 camera(in float3 ro, in float3 rd, float rot)
comp_195={
comp_196=float3 forward = normalize(rd - ro);
comp_197=float3 worldUp = float3(sin(rot), cos(rot), 0.0);
comp_198=float3 x = normalize(cross(forward, worldUp));
comp_199=float3 y = normalize(cross(x, forward));
comp_200=return float3x3(x, y, forward);
comp_201=}
comp_202=
comp_203=
comp_204=shader_body {
comp_205= float4 fragColor = 0;
comp_206= float2 fragCoord  = uv;
comp_207=// CONV: Center on screen, then try some aspect correction
comp_208=uv = (uv*2) - 1;
comp_209=uv.x+= 0.2;
comp_210=uv.y+= -0.9;
comp_211=uv *= aspect.xy;
comp_212=// CONV: Adjust this to flip the output (±uv.x, ±uv.y)
comp_213=uv = float2(uv.x, -uv.y);
comp_214=
comp_215=// 	float2 uv = fragCoord.xy / texsize.xy;
comp_216=    uv = uv * 2.0 - 1.0;
comp_217=    float3 camPos = float3(3., -1.5, time*5.);
comp_218=    float3 camDir = camPos+float3(-1.25,0.1, 1.);
comp_219=    float3x3 cam = camera(camPos, camDir, 0.);
comp_220=
comp_221=    float3 rayDir = mul(cam, normalize(float3(uv, 0.8)));
comp_222=    
comp_223=    Ray ray;
comp_224=
comp_225=    ray.ro = camPos;
comp_226=    ray.rd = rayDir;
comp_227=    
comp_228=    float4 col = render(ray);
comp_229=    
comp_230=	ret = float4(1.-col.xyz,clamp(1.-col.w/MAXDIST, 0., 1.));
comp_231=}
