MILKDROP_PRESET_VERSION=201
PSVERSION=4
PSVERSION_WARP=4
PSVERSION_COMP=4
comp_1=// balkhan + IkeC - Tunnel Cylinders / https://www.shadertoy.com/view/MlsfWS
comp_2=// Transpiled to HLSL using Milkwave
comp_3=
comp_4=float mod_conv(float x, float y) { return x - y * floor(x / y); }
comp_5=float2 mod_conv(float2 x, float2 y) { return x - y * floor(x / y); }
comp_6=float3 mod_conv(float3 x, float3 y) { return x - y * floor(x / y); }
comp_7=float4 mod_conv(float4 x, float4 y) { return x - y * floor(x / y); }
comp_8=
comp_9=float2	march(float3 pos, float3 dir);
comp_10=float3	camera(float2 uv_conv);
comp_11=void	rotate(inout float2 v, float angle);
comp_12=float	sdTorus( float3 p, float2 t, float phase );
comp_13=float	mylength(float2 p);
comp_14=
comp_15=#define LIGHT
comp_16=
comp_17=float 	t;
comp_18=// time
comp_19=float3	ret_col;
comp_20=// color
comp_21=#ifdef LIGHT
comp_22=float3	h;
comp_23=// light amount
comp_24=#endif
comp_25=
comp_26=#define I_MAX		200.
comp_27=#define E			0.0001
comp_28=#define FAR			50
comp_29=#define	PI			3.14159
comp_30=#define	TAU			PI*2.
comp_31=
comp_32=/*
comp_33=** Leon's mod polar from : https:
comp_34=// www.shadertoy.com/view/XsByWd
comp_35=*/
comp_36=
comp_37=float2 modA (float2 p, float count) {
comp_38=  float an = TAU/count;
comp_39=  float a = atan2(p.y,p.x)+an*.5;
comp_40=  a = mod_conv(a, an)-an*.5;
comp_41=  return float2(cos(a),sin(a))*length(p);
comp_42=}
comp_43=
comp_44=/*
comp_45=** end mod polar
comp_46=*/
comp_47=
comp_48=float	scene(float3 p)
comp_49={
comp_50=  float	var;
comp_51=  float	mind = 1e5;
comp_52=  float3	op = p;
comp_53=  #ifdef	FUNKY
comp_54=  var =
comp_55=  step(-1.+cos( floor( p.z*6.)/6.+time*1.)*3.14, mod_conv(atan(p.x, p.y ), 6.28)-3.14 )
comp_56=  *
comp_57=  step(mod_conv(atan(p.x, p.y ), 6.28)-3.14-1.5, -1.+cos( floor( p.z*3.)/1.+time*1.)*3.14)
comp_58=
comp_59=  *
comp_60=  step(
comp_61=  .0
comp_62=  ,
comp_63=  (length(frac(float2(op.z, min(abs(op.x), abs(op.y)))*10.)-.5)-.2)
comp_64=  )
comp_65=
comp_66=  ;
comp_67=  #else
comp_68=  var =
comp_69=  atan2(p.x, p.y)*1.+0.;
comp_70=  #endif
comp_71=  var = cos(var*1.+floor(p.z) +time*(mod_conv(floor(p.z), 2.)-1. == 0. ? -1. : 1.) );
comp_72=  float	dist_cylinder = 1e5;
comp_73=  ret_col = 1.-float3(.5-var*.5, .5, .3+var*.5);
comp_74=  mind = length(p.xy)-1.+.1*var;
comp_75=  #ifdef HOLES
comp_76=  mind = max(mind, var*-(length(frac(float2(op.z, min(abs(op.x), abs(op.y)))*10.)-.5)-.1) );
comp_77=  #endif
comp_78=  mind = max(mind, -(length(p.xy)-.9+.1*var));
comp_79=  p.xy = modA(p.yx, 50.+50.*sin(p.z*.25) );
comp_80=  p.z = frac(p.z*3.)-.5;
comp_81=  if (var != 0.)
comp_82=  {
comp_83=    dist_cylinder = length(p.zy)-.0251-.25*sin(op.z*5.5);
comp_84=    dist_cylinder = max(dist_cylinder, -p.x+.4 +clamp(var, .0, 1.) );
comp_85=  }
comp_86=
comp_87=  mind =
comp_88=  min
comp_89=  (
comp_90=  mind
comp_91=  ,
comp_92=  dist_cylinder
comp_93=  );
comp_94=
comp_95=  #ifdef LIGHT
comp_96=  h += float3(.5,.8,.5)*(var!=0.?1.:0.)*.0125/(.01+max(mind-var*.1, .0001)*max(mind-var*.1, .0001) );
comp_97=  #endif
comp_98=
comp_99=  return (mind);
comp_100=}
comp_101=
comp_102=float2	march(float3 pos, float3 dir)
comp_103={
comp_104=  float2	dist = float2(0.0, 0.0);
comp_105=  float3	p = float3(0.0, 0.0, 0.0);
comp_106=  float2	s = float2(0.0, 0.0);
comp_107=
comp_108=  for (float i = -1.; i < I_MAX; ++i)
comp_109=  {
comp_110=    p = pos + dir * dist.y;
comp_111=    dist.x = scene(p);
comp_112=    dist.y += dist.x*.2;
comp_113=    // makes artefacts disappear
comp_114=    if (dist.x < E || dist.y > FAR)
comp_115=    {
comp_116=      // CONV: break unsupported, see Milkwave manual
comp_117=      i = I_MAX;
comp_118=    }
comp_119=
comp_120=    s.x++;
comp_121=  }
comp_122=
comp_123=  s.y = dist.y;
comp_124=  return (s);
comp_125=}
comp_126=
comp_127=float	mylength(float2 p)
comp_128={
comp_129=  float	ret;
comp_130=
comp_131=  p = p*p*p*p;
comp_132=  p = p*p;
comp_133=  ret = (p.x+p.y);
comp_134=  ret = pow(ret, 1./8.);
comp_135=
comp_136=  return ret;
comp_137=}
comp_138=
comp_139=void rotate(inout float2 v, float angle)
comp_140={
comp_141=  float s = sin(angle);
comp_142=  float c = cos(angle);
comp_143=  v = float2(c * v.x + s * v.y,
comp_144=  -s * v.x + c * v.y);
comp_145=
comp_146=}
comp_147=
comp_148=float2	rot(float2 p, float2 ang_c)
comp_149={
comp_150=  float	c = cos(ang_c.x);
comp_151=  float	s = sin(ang_c.y);
comp_152=  float2x2	m = float2x2(c, -s, s, c);
comp_153=
comp_154=  return mul(p,transpose(m));
comp_155=}
comp_156=
comp_157=float3	camera(float2 uv_conv)
comp_158={
comp_159=  float		fov = 1.;
comp_160=  float3		forw  = float3(0.0, 0.0, -1.0);
comp_161=  float3    	right = float3(1.0, 0.0, 0.0);
comp_162=  float3    	up    = float3(0.0, 1.0, 0.0);
comp_163=
comp_164=  return (normalize((uv_conv.x) * right + (uv_conv.y) * up + fov * forw));
comp_165=}
comp_166=
comp_167=shader_body {
comp_168=  float4 c_out = 0;
comp_169=  // CONV: Center on screen, then try some aspect correction
comp_170=
comp_171=  // CONV: Adjust this to flip the output (±uv.x, ±uv.y)
comp_172=  // uv = float2(uv.x, -uv.y);
comp_173=  uv.x = uv.x-0.5;
comp_174=
comp_175=  uv.y = uv.y+0.3;
comp_176=
comp_177=  float2 f = uv;
comp_178=  f.y-=0.4;
comp_179=
comp_180=  uv *= aspect.xy;
comp_181=  f *= aspect.xy;
comp_182=
comp_183=  t  = time*.125;
comp_184=
comp_185=  float3	col = float3(0., 0., 0.);
comp_186=  float2 R = uv.xy,
comp_187=  uv_c  = float2(f-R/2.) / R.y;
comp_188=
comp_189=  float3	dir = camera(uv_c);
comp_190=  float3	pos = float3(.0, .0, 0.0);
comp_191=
comp_192=  pos.z = 4.5-time*2.;
comp_193=
comp_194=  #ifdef bass_smooth
comp_195=    pos.z += (int)vis_version > 2 ? 0.05*vis_intensity+vis_shift : (0.3*smoothstep(0,2,(int)vis_version == 1 ? bass_smooth : bass_att))*vis_intensity+vis_shift;
comp_196=  #else
comp_197=    pos.z += 0.15*smoothstep(0,2,bass_att);
comp_198=  #endif
comp_199=
comp_200=  #ifdef LIGHT
comp_201=  h = float3(0., 0., 0.);
comp_202=  #endif
comp_203=  float2	inter = (march(pos, dir));
comp_204=  if (inter.y <= FAR)
comp_205=  col.xyz = ret_col*(1.-inter.x*.0025);
comp_206=  else
comp_207=  col *= 0.;
comp_208=
comp_209=  #ifdef LIGHT
comp_210=  col += h*.005125;
comp_211=  #endif
comp_212=
comp_213=  col *= 0.9;
comp_214=
comp_215=  #ifdef bass_smooth
comp_216=    col.r += (int)vis_version > 2 ? 0.05*vis_intensity+vis_shift : (0.7*(smoothstep(0,2,(int)vis_version == 1 ? bass_smooth : bass_att)-0.5))*vis_intensity+vis_shift;
comp_217=  #else
comp_218=    col.r += 0.05*(smoothstep(0,2,bass_att)-0.5);
comp_219=  #endif
comp_220=
comp_221=  c_out =  float4(col,1.0);
comp_222=  ret = c_out;
comp_223=}
